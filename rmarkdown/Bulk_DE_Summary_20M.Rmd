---
title: "DE analysis 20M reads subsample"
author: "Yupei & Ash"
date: '`r Sys.Date()`'
version: 'v3.1_lfc0'
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_float: yes
    number_sections: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: '4'
params:
  random_seed: 2024
  cache_dir: NULL
  fig.path: NULL
  sirv_ercc_gtf: '/vast/projects/LongBench/reference_files/SIRV_Set4_Norm_Sequences_20210507/SIRV_ERCC_longSIRV_multi-fasta_20210507.gtf'
  sequins_gtf: '/vast/projects/LongBench/reference_files/Sequin_resources/v2.4/rnasequin_annotation_2.4.gtf'
  sequins_tsv: '/vast/projects/LongBench/reference_files/Sequin_resources/v2.4/rnasequin_isoforms_2.4.tsv'
  human_gtf: '/vast/projects/LongBench/reference_files/GRCh38/gencode.v44.annotation.gtf'
  sirv_csv: '/vast/projects/LongBench/reference_files/SIRV_Set4_Norm_Sequences_20210507/SIRV_set4_concentration.csv'
  ont_bulk_oarfish_dir: '/vast/projects/LongBench/analysis/main_workflow/result/rarefraction_analysis/oarfish/ont_bulk/20M'
  pb_bulk_oarfish_dir: '/vast/projects/LongBench/analysis/main_workflow/result/rarefraction_analysis/oarfish/pb_bulk/20M'
  ont_drnd_oarfish_dir: '/vast/projects/LongBench/analysis/main_workflow/result/rarefraction_analysis/oarfish/dRNA_bulk/20M'
  ill_bulk_salmon_dir: '/vast/projects/LongBench/analysis/main_workflow/result/rarefraction_analysis/salmon/20M'
  expected_de_table: '/vast/projects/LongBench/reference_files/Expected_DE.csv'
  bulk_meta: "/vast/projects/LongBench/sequencing_data/illumina_bulk/metadata.txt"
  output_rds: "/vast/projects/LongBench/analysis/workflow/rmarkdown/RDS/Bulk_identification_DE_M20.rds"
  log2FC_cutoff: 0

---

# Setup: Create DGE from Input

**Bulk RNA-seq** was performed to analyze gene and transcript expression across various cancer cell lines using both short- and long-read sequencing platforms.

1.  **Samples**:

    \- Total: 8 cancer cell lines (H146, H69, H526, H211, SHP77, H1975, H2228, HCC827) for each platform.

2.  **Groups by Cancer Cell Type**: - **Small Cell Lung Cancer (SCLC)**:

    \- **Subtype A (SCLC_A)**: H146, H69, SHP77.\

    -   **Subtype P (SCLC_P)**: H526, H211.\
    -   **Lung Adenocarcinoma (LUAD)**: - H1975, H2228, HCC827.

3.  **Sequencing Platforms**:

    \- **Short-Read Sequencing**: Illumina.

    \- **Long-Read Sequencing**: PacBio ,  Oxford Nanopore Technologies (ONT) (`ONT_1` (cDNA sequencing), `ONT_2` (dRNA sequencing))

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	fig.height = 5,
	fig.width = 7,
	warning = FALSE,
	cache = FALSE
)
```

```{r Libraries, include=FALSE}
library(limma)
library(edgeR)
library(tidyverse)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(glue)
library(ggplot2)
library(gridExtra)
library(ggExtra)
library(knitr)
library(kableExtra)
library(rtracklayer)
library(scales)
library(UpSetR)
library(ggtree)
library(aplot)
source("/vast/projects/LongBench/analysis/workflow/scripts/Rfunctions.R")
output_list <- list() # used to store result for downstream analysis

# setup some conflict functions
rename <- dplyr::rename
select <- dplyr::select

knitr::opts_chunk$set(
  cache = !is.null(params$cache_dir),  # Enable caching only if cache_dir is provided
  fig.width = 15,                     # Set default figure width
  fig.height = 10,                    # Set default figure height
  warning = FALSE,                    # Suppress warnings in the output
  fig.path = params$fig.path,         # Set figure path (NULL if not provided)
  dev = if (!is.null(params$fig.path)) c("png", "svg") else NULL  # Set output devices if fig.path is provided
)

# Set cache.path only if params$cache_dir is not NULL
if (!is.null(params$cache_dir)) {
  knitr::opts_chunk$set(cache.path = params$cache_dir)
}
```

```{r Input filename setup, include=FALSE, eval=F}
params <- list(
  random_seed = 2024,
  cache_dir = NULL,
  sirv_ercc_gtf = '/vast/projects/LongBench/reference_files/SIRV_Set4_Norm_Sequences_20210507/SIRV_ERCC_longSIRV_multi-fasta_20210507.gtf',
  sequins_gtf = '/vast/projects/LongBench/reference_files/Sequin_resources/v2.4/rnasequin_annotation_2.4.gtf',
  sequins_tsv = '/vast/projects/LongBench/reference_files/Sequin_resources/v2.4/rnasequin_isoforms_2.4.tsv',
  human_gtf = '/vast/projects/LongBench/reference_files/GRCh38/gencode.v44.annotation.gtf',
  sirv_csv = '/vast/projects/LongBench/reference_files/SIRV_Set4_Norm_Sequences_20210507/SIRV_set4_concentration.csv',
  ont_bulk_oarfish_dir = "/vast/projects/LongBench/analysis/lr_bulk/result/oarfish_cov_output/ont_bulk",
  pb_bulk_oarfish_dir = "/vast/projects/LongBench/analysis/lr_bulk/result/oarfish_cov_output/pb_bulk",
  ont_drnd_oarfish_dir = "/vast/projects/LongBench/analysis/lr_bulk/result/oarfish_cov_output/dRNA_bulk",
  ill_bulk_salmon_dir = "/vast/projects/LongBench/analysis/sr_bulk/result/salmon/salmon_quant",
  bulk_meta = "/vast/projects/LongBench/sequencing_data/illumina_bulk/metadata.txt",
  log2FC_cutoff= 0
)
```

```{r color code, include=FALSE}
color_palette <- c(
  PacBio = "#df1995",
  ONT = "#00789b",
  ONT_1 = "#04476c", # ONT cDNA
  ONT_2 = "#24cdcd", # ONT dRNA
  Illumina = "#e88b20"
)
```

```{r function for splitting the transcript origin, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
is.sequins <- function(dge) {grepl("^R", rownames(dge))}
is.human <- function(dge) {grepl("^ENS", rownames(dge))}
is.sirv_or_ercc <- function(dge) {!is.human(dge) & !is.sequins(dge)} # this is the whole SIRV set4 (ERCC + SIRV E0 + Long SIRV)
is.sirv_E0 <- function(dge) {grepl("^SIRV\\d{3}$", rownames(dge))} 
is.sirv_all <- function(dge) {grepl("^SIRV", rownames(dge))} # including all SIRV E0 and Long SIRV
is.long_sirv <- function(dge) {grepl("^SIRV\\d{4}", rownames(dge))}
is.ercc <- function(dge) {!is.human(dge) & !is.sequins(dge) & !is.sirv_all(dge)}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
calcTxNum <- function(G.Tx.map){
  geneid = rep(NA, nrow(G.Tx.map))
  txcount = table(G.Tx.map$gene_id)
  txnum = as.numeric(txcount[match(G.Tx.map$gene_id, names(txcount))])
}
# SIRV
SIRV_tx <- GenomicFeatures::makeTxDbFromGFF(params$sirv_ercc_gtf, format = "gtf") %>% GenomicFeatures::transcripts(columns = c("tx_id", "tx_name", "gene_id"))
SIRV.G.Tx.map <- tibble(
  gene_id = SIRV_tx$gene_id %>% unlist,
  tx_name = SIRV_tx$tx_name
)
rm(SIRV_tx)
SIRV.G.Tx.map$tx_count <- SIRV.G.Tx.map %>% calcTxNum

# Sequins
sequins_tx  <- GenomicFeatures::makeTxDbFromGFF(params$sequins_gtf, format = "gtf") %>% GenomicFeatures::transcripts(columns = c("tx_id", "tx_name", "gene_id"))
sequins.G.Tx.map <- tibble(
  gene_id = sequins_tx$gene_id %>% unlist,
  tx_name = sequins_tx$tx_name
)
rm(sequins_tx)
sequins.G.Tx.map$tx_count <- sequins.G.Tx.map %>% calcTxNum

# Human
human_tx  <- GenomicFeatures::makeTxDbFromGFF(params$human_gtf, format = "gtf") %>% GenomicFeatures::transcripts(columns = c("tx_id", "tx_name", "gene_id"))
human.G.Tx.map <- tibble(
  gene_id = human_tx$gene_id %>% unlist,
  tx_name = human_tx$tx_name
)
rm(human_tx)
human.G.Tx.map$tx_count <- human.G.Tx.map %>% calcTxNum
```

```{r Create DGE from input, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
bulk.meta <- read.csv(params$bulk_meta)
rownames(bulk.meta) <- bulk.meta$sample

# SR salmon
ill_bulk.dge <- get_dge_from_salmon(params$ill_bulk_salmon_dir, ".*/")

# LR oarfish
ont_bulk.dge.oarfish <- get_dge_from_oarfish(params$ont_bulk_oarfish_dir, ".*/")
pb_bulk.dge.oarfish <- get_dge_from_oarfish(params$pb_bulk_oarfish_dir, ".*/")
ont_drna.dge.oarfish <- get_dge_from_oarfish(params$ont_drnd_oarfish_dir, ".*/")
```

# Count data Preprocessing

1.  Aggregate transcript counts to gene level using `tximport` with unfiltered transcript counts
2.  Filter out lowly expressed genes and transcript using `filterByExpr` for each dataset, using default parameters

-   The filtering will be done on single dataset level, and the union of the filtered genes will be used for the downstream analysis
-   Note: The starting number of gene/transcript is smaller for the salmon pseudoalignment method compared to the kallisto and oarfish methods. This is due to the fact that the genecode transcript FASTA has more transcript/gene than their annotation GTF file. Given the proportion is tiny (\<0.2% transcripts), to keep the analysis consistent, we will remove the genes (either expressed or not) that are not present in salmon output from the kallisto and oarfish datasets.

3.  Normalise the gene counts using `calcNormFactors` with `TMM` methods for each dataset

## Aggregate transcript counts to gene level using `tximport` with unfiltered transcript counts

```{r Aggregate to gene level, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
library(tximport) # install latest version from github

# Extract tx_name and gene_id columns from human , sequins and SIRV
human_tx2gene <- human.G.Tx.map[, c("tx_name", "gene_id")]
sequins_tx2gene <- sequins.G.Tx.map[, c("tx_name", "gene_id")]
SIRV_tx2gene <- SIRV.G.Tx.map[, c("tx_name", "gene_id")]
combined_tx2gene <- rbind(human_tx2gene, sequins_tx2gene, SIRV_tx2gene)

# Get quant.sf file paths
get_quant_paths <- function(dirs, file_name) {
  # Generate file paths for quantification files
  quant_paths <- file.path(dirs, file_name)
  return(quant_paths)
}

# Define directories with their corresponding expected file names
oarfish_dirs <- list(
  ill_bulk = list(dir = params$ill_bulk_salmon_dir, file_name = "quant.sf"),
  ont_bulk = list(dir = params$ont_bulk_oarfish_dir, file_name = ".quant"),
  pb_bulk = list(dir = params$pb_bulk_oarfish_dir, file_name = ".quant"),
  drna_bulk = list(dir = params$ont_drnd_oarfish_dir, file_name = ".quant")
)

# Apply function to each directory to get all quant file paths
quant_paths <- lapply(oarfish_dirs, function(dir_info) {
  # Get the directory and file name from dir_info
  dir <- dir_info$dir
  file_name <- dir_info$file_name
  
  # List all subdirectories and get the quant file paths
  sub_dirs <- list.dirs(dir, full.names = TRUE, recursive = FALSE)
  get_quant_paths(sub_dirs, file_name)
})

# Flatten the list of quant_paths into a named list
quant_paths <- lapply(quant_paths, unlist)

# Process each quant path for different bulk types
ill_bulk.gene.dge <- get_dge_from_txi(quant_paths$ill_bulk, ".*/", "salmon")
ont_bulk.gene.dge <- get_dge_from_txi(quant_paths$ont_bulk, ".*/", "oarfish")
pb_bulk.gene.dge <- get_dge_from_txi(quant_paths$pb_bulk, ".*/", "oarfish")
drna_bulk.gene.dge <- get_dge_from_txi(quant_paths$drna_bulk, ".*/", "oarfish")
```

## Filter out lowly expressed genes and transcript using `filterByExpr` for each dataset, using default parameters

```{r gene filtering for DE, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
#GENE 
## 1. get common genes
common_genes <- Reduce(intersect, lapply(list(ill_bulk.gene.dge, ont_bulk.gene.dge, pb_bulk.gene.dge, drna_bulk.gene.dge), rownames))

ill_bulk.gene.dge <- ill_bulk.gene.dge[common_genes, ]
ont_bulk.gene.dge <- ont_bulk.gene.dge[common_genes, ]
pb_bulk.gene.dge <- pb_bulk.gene.dge[common_genes, ]
drna_bulk.gene.dge <- drna_bulk.gene.dge[common_genes, ]

## 2. filter by expression
keep <- filterByExpr(ill_bulk.gene.dge, group = ill_bulk.gene.dge$samples$group) &
          filterByExpr(ont_bulk.gene.dge, group = ont_bulk.gene.dge$samples$group) &
          filterByExpr(pb_bulk.gene.dge, group = pb_bulk.gene.dge$samples$group) &
          filterByExpr(drna_bulk.gene.dge, group = drna_bulk.gene.dge$samples$group)

#table(keep)
ill_bulk.gene.dge <- ill_bulk.gene.dge[keep, ]
ont_bulk.gene.dge <- ont_bulk.gene.dge[keep, ]
pb_bulk.gene.dge <- pb_bulk.gene.dge[keep, ]
drna_bulk.gene.dge <- drna_bulk.gene.dge[keep, ]

output_list[["gene_discovery"]] <- common_genes[keep]

```

```{r transcript filtering for DE, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Transcript
## 1. get common transcripts
common_tx <- Reduce(intersect, lapply(list(ill_bulk.dge, ont_bulk.dge.oarfish, pb_bulk.dge.oarfish, ont_drna.dge.oarfish), rownames))

ill_bulk.dge <- ill_bulk.dge[common_tx, ]
ont_bulk.dge.oarfish <- ont_bulk.dge.oarfish[common_tx, ]
pb_bulk.dge.oarfish <- pb_bulk.dge.oarfish[common_tx, ]
ont_drna.dge.oarfish <- ont_drna.dge.oarfish[common_tx, ]

## 2. filter by expression
keep <- filterByExpr(ill_bulk.dge, group = ill_bulk.dge$samples$group, min.count=5) &
          filterByExpr(ont_bulk.dge.oarfish, group = ont_bulk.dge.oarfish$samples$group, min.count=5) &
          filterByExpr(pb_bulk.dge.oarfish, group = pb_bulk.dge.oarfish$samples$group, min.count=5) &
          filterByExpr(ont_drna.dge.oarfish, group = ont_drna.dge.oarfish$samples$group, min.count=5)
#table(keep)

ill_bulk.dge <- ill_bulk.dge[keep, ]
ont_bulk.dge.oarfish <- ont_bulk.dge.oarfish[keep, ]
pb_bulk.dge.oarfish <- pb_bulk.dge.oarfish[keep, ]
ont_drna.dge.oarfish <- ont_drna.dge.oarfish[keep, ]

output_list[["txi_discovery"]] <- common_tx[keep]
```

## Normalise the gene and transcript counts using `calcNormFactors` with `TMM` methods for each dataset, separately for human

```{r TMM normalisation, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
### 4. Normalise the gene counts using `calcNormFactors` with `TMM` methods for each dataset
ill_bulk.gene.dge <- calcNormFactors(ill_bulk.gene.dge, method = "TMM")
ont_bulk.gene.dge <- calcNormFactors(ont_bulk.gene.dge, method = "TMM")
pb_bulk.gene.dge <- calcNormFactors(pb_bulk.gene.dge, method = "TMM")
drna_bulk.gene.dge <- calcNormFactors(drna_bulk.gene.dge, method = "TMM")


### 4. Normalise the transcript counts using `calcNormFactors` with `TMM` methods for each dataset
ill_bulk.dge <- calcNormFactors(ill_bulk.dge, method = "TMM")
ont_bulk.dge.oarfish <- calcNormFactors(ont_bulk.dge.oarfish, method = "TMM")
pb_bulk.dge.oarfish <- calcNormFactors(pb_bulk.dge.oarfish, method = "TMM")
ont_drna.dge.oarfish <- calcNormFactors(ont_drna.dge.oarfish, method = "TMM")

```

# MDS (Merged)

## Merge DGElist

NOTE: The merged DGElist will only be used for the MDS plot. The DE analysis will be done separately for each dataset.

```{r Merge DGEs, include=FALSE}
# Gene
ill_bulk.gene.dge$samples$platform <- "Illumina"
ont_bulk.gene.dge$samples$platform <- "ONT cDNA"
pb_bulk.gene.dge$samples$platform <- "PacBio"
drna_bulk.gene.dge$samples$platform <- "ONT dRNA"
bulk.gene.dge.merge <- cbind(
  ill_bulk.gene.dge,
  ont_bulk.gene.dge,
  pb_bulk.gene.dge,
  drna_bulk.gene.dge
)

# Transcript
ill_bulk.dge$samples$platform <- "Illumina"
ill_bulk.dge.copy <- ill_bulk.dge
ill_bulk.dge.copy$genes$EffectiveLength <- NULL
ont_bulk.dge.oarfish$samples$platform <- "ONT cDNA"
pb_bulk.dge.oarfish$samples$platform <- "PacBio"
ont_drna.dge.oarfish$samples$platform <- "ONT dRNA"

bulk.tx.dge.merge <- cbind(
  ill_bulk.dge.copy,
  ont_bulk.dge.oarfish,
  pb_bulk.dge.oarfish,
  ont_drna.dge.oarfish
)
```

```{r include=FALSE}
norm_and_mds <- function(dge) {
  dge <- calcNormFactors(dge, method = "TMM")
  mds <- plotMDS(dge, plot = FALSE)
  return(mds)
}
myMDS <- function(dge, mds) {
  # normalisation
  mds_data <- data.frame(
    Dim1 = mds$x,
    Dim2 = mds$y,
    cell.line = dge$sample$sample,
    Cancer.type = dge$sample$group,
    Data.type = dge$sample$platform,
    Sequins.mix = dge$samples$sequins
  )

  p <- ggplot(mds_data, aes(x = Dim1, y = Dim2, color = Cancer.type, shape = Data.type, label=cell.line)) +
    geom_point(size = 3, alpha = 0.6) + # Plot points
    #geom_text_repel(size = 3) +
    labs(title = "MDS plot", 
        x = paste0("Dimension 1 (", round(mds$var.explained[1]*100, 2), "%)" ) , 
        y = paste0("Dimension 2 (", round(mds$var.explained[2]*100, 2), "%)" )) +
    scale_color_viridis_d() + # Set color scale
    theme_minimal() 
  return(p)
}
```

## Gene-level MDS

Here are key observations from the gene-level MDS plots:

1.  **Cancer type clustering:** samples cluster clearly by cancer type (**LUAD, SCLC type a, SCLC type p**), reflecting distinct gene expression profiles.
2.  **Platform type impact:** sequencing platforms (**Illumina, ONT cDNA, ONT dRNA, PacBio)** show slight variability but largely preserve cancer type clustering, indicating that the biological variation observed is largely due to cancer cell-type.
3.  **Variance explained:** The first two dimensions explain **19.25%** and **9.84%** of the variation, respectively, effectively separating sample groups.

```{r echo=FALSE, message=FALSE, warning=FALSE, fig.height=3, fig.width=8 }
mds <- norm_and_mds(bulk.gene.dge.merge[is.human(bulk.gene.dge.merge),])
p1 <- myMDS(bulk.gene.dge.merge[is.human(bulk.gene.dge.merge), ], mds) + ggtitle("Human gene counts")
p2 <- myMDS(bulk.gene.dge.merge[is.human(bulk.gene.dge.merge), ], mds) + ggtitle("Human gene counts")  + 
            aes(color = Data.type, shape = Cancer.type) + 
            scale_color_manual(values = color_palette[c("Illumina", "ONT_1", "ONT_2", "PacBio")] %>% unname())
p1 | p2 
```

## Transcript-level MDS

Here are key observations from the transcript-level MDS plots:

1.  **Cancer type clustering**: Samples still cluster by cancer type (**LUAD, SCLC type a, SCLC type p**), but the separation between groups appears slightly less distinct compared to the gene-level data. Particularly SCLC type a and SCLC type p cluster closer together on the transcript-level MDS plot.
2.  **Platform type impact**: Different sequencing platforms (**Illumina, ONT cDNA, ONT dRNA, PacBio**) show more variability at the transcript-level as samples seem to cluster largely based on sequencing platform for transcript-level analysis compared to gene-level analysis.
3.  **Variance explained**: The first two dimensions explain 11.07% and 9.85% of the variation, respectively.

```{r echo=FALSE, fig.width=15, message=FALSE, warning=FALSE, fig.height=3, fig.width=8 }
mds <- norm_and_mds(bulk.tx.dge.merge[is.human(bulk.tx.dge.merge),])
p1 <- myMDS(bulk.tx.dge.merge[is.human(bulk.tx.dge.merge), ], mds) + ggtitle("Human transcript counts") + 
  aes(color = Data.type, shape = Cancer.type) + 
  scale_color_manual(values = color_palette[c("Illumina", "ONT_1", "ONT_2", "PacBio")] %>% unname())

p2 <- myMDS(bulk.tx.dge.merge[is.human(bulk.tx.dge.merge), ], mds) + ggtitle("Human transcript counts")

p2 | p1
```

# Differential gene expression

## DGE edgeR (Salmon and Oarfish)

DGE analysis is performed on subsets for human genes, each with potentially different library size distributions compared to the entire dataset which included human genes and spikeins (sequins and SIRVs). To ensure consistency:

1.  Filter by Expression: Lowly expressed genes are filtered using `filterByExpr` for each subset of human-genes.
2.  Normalization: Gene counts are normalized using the `calcNormFactors` function in edgeR with the `TMM` method for each subset of human-genes.
3.  Differential Expression: Differential expression is assessed using a GLM-based model with the `glmQLFit` and `glmQLFTest` functions, comparing:

-   SCLC type a vs. LUAD
-   SCLC type p vs. LUAD
-   SCLC type a vs. SCLC type p
-   ***Model: model.matrix(\~0 + group, data = dge\$samples)***
4. Differential expression gene and transcript lists are defined using `DecideTests` with a log2 fold change cutoff of `r params$log2FC_cutoff` and adjusted p<0.05.
```{r echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
DGE.edgeR_human <- function(dge, norm.method = "TMM") {
  # QC and normalization
  filter <- filterByExpr(dge, group = dge$samples$group)
  dge <- dge[filter, , keep.lib.sizes = FALSE]
  
  if (!is.null(norm.method)) {
     dge <- calcNormFactors(dge, method = norm.method)
  }
  
  design <- model.matrix(~0 + group, data = dge$samples)
  dge <- estimateDisp(dge, design)
  qlfit <- glmQLFit(dge, design)
  
  contrasts <- makeContrasts(
    AvsL = groupsclc_a - groupluad,
    PvsL = groupsclc_p - groupluad,
    AvsP = groupsclc_a - groupsclc_p,
    levels = design
  )
  
  AvsL.QLF.test <- glmQLFTest(qlfit, contrast = contrasts[, "AvsL"])
  PvsL.QLF.test <- glmQLFTest(qlfit, contrast = contrasts[, "PvsL"])
  AvsP.QLF.test <- glmQLFTest(qlfit, contrast = contrasts[, "AvsP"])
  
  list(
    AvsL.DE = AvsL.QLF.test,
    PvsL.DE = PvsL.QLF.test,
    AvsP.DE = AvsP.QLF.test 
  )
}

# DEG analsysis on human genes only 
ill_bulk.dge_human.list <- DGE.edgeR_human(ill_bulk.gene.dge[is.human(ill_bulk.gene.dge),])
ont_bulk.dge_human.list <- DGE.edgeR_human(ont_bulk.gene.dge[is.human(ont_bulk.gene.dge),])
drna_bulk.deg_human.list <- DGE.edgeR_human(drna_bulk.gene.dge[is.human(drna_bulk.gene.dge),])
pb_bulk.dge_human.list <- DGE.edgeR_human(pb_bulk.gene.dge[is.human(pb_bulk.gene.dge), ])
```

1.  ***SCLC type a vs. LUAD:***
    -   [Illumina](./DGE_summary/DGE_Glimma_HTML/Illumina_AvsL_volcano_plot.html)
    -   [PacBio](./DGE_summary/DGE_Glimma_HTML/PacBio_AvsL_volcano_plot.html)
    -   [ONT cDNA](./DGE_summary/DGE_Glimma_HTML/ONT_AvsL_volcano_plot.html)
    -   [ONT dRNA](./DGE_summary/DGE_Glimma_HTML/dRNA_AvsL_volcano_plot.html)
2.  ***SCLC type p vs. LUAD:***
    -   [Illumina](./DGE_summary/DGE_Glimma_HTML/Illumina_PvsL_volcano_plot.html)
    -   [PacBio](./DGE_summary/DGE_Glimma_HTML/PacBio_PvsL_volcano_plot.html)
    -   [ONT cDNA](./DGE_summary/DGE_Glimma_HTML/ONT_PvsL_volcano_plot.html)
    -   [ONT dRNA](./DGE_summary/DGE_Glimma_HTML/dRNA_PvsL_volcano_plot.html)
3.  ***SCLC type a vs. SCLC type p:***
    -   [Illumina](./DGE_summary/DGE_Glimma_HTML/Illumina_AvsP_volcano_plot.html)
    -   [PacBio](./DGE_summary/DGE_Glimma_HTML/PacBio_AvsP_volcano_plot.html)
    -   [ONT cDNA](./DGE_summary/DGE_Glimma_HTML/ONT_AvsP_volcano_plot.html)
    -   [ONT dRNA](./DGE_summary/DGE_Glimma_HTML/dRNA_AvsP_volcano_plot.html)

## Cross-platform comparison DGE human (upset)

Here the differential gene expression (DGE) results visualized in the upset plots show:

1.  ***SCLC_A vs LUAD:*** 580 shared differential expressed genes across all platforms. Highlighting platform-specific contributions to DGE detection with largest intersections from PacBio (790 genes).

2.  ***SCLC_P vs LUAD:*** The total number of differential expressed genes is smaller compared to SCLC_A vs LUAD. 140 shared differential expressed genes across all platforms. Highlighting platform-specific contributions to DGE detection with largest intersections from PacBio (173 genes).

3.  ***SCLC_A vs SCLC_P:*** A significantly smaller number of genes are differential expressed compared to LUAD comparisons. 16 shared differential expressed genes across all platforms. Highlighting platform-specific contributions to DGE detection with largest intersections from Illumina (48 genes).

***Overall, the results suggest:*** PacBio tends to identify highest number of platform-specific differential expressed genes. Differences between cancer subtypes (SCLC_A vs SCLC_P) are less pronounced compared to differences with LUAD.

```{r upset plot function, include=FALSE}

complex_upset_plot <- function(lst) {
  # apply decideTests to each list element
  DEGs <- lapply(lst, function(x) {
    x <- x %>% decideTests(lfc=params$log2FC_cutoff)
    x <- rownames(x)[x != 0]
    return(x)
  })

  long_df <- stack(DEGs)

  # Make the binary membership matrix
  binary_matrix <- long_df %>%
    mutate(present = 1) %>%
    pivot_wider(names_from = ind, values_from = present, values_fill = 0)

  p <- ComplexUpset::upset(
    binary_matrix %>% select(-values) %>% as.data.frame(),
    intersect = names(lst),
    base_annotations=list(
        'Intersection size'=ComplexUpset::intersection_size(
            counts=TRUE,
            text=element_text(size = 3, vjust=-0.2)
        )
    ),
    wrap = TRUE
  )

  return(list(
    plot = p,
    matrix = binary_matrix %>% rename(Gene = values)
  ))
}
```

```{r upset plot dge human, echo=FALSE, fig.height=9, fig.width=8}
# Upset plot
lst <- list(
  "Illumina" = ill_bulk.dge_human.list$AvsL.DE,
  "ONT cDNA" = ont_bulk.dge_human.list$AvsL.DE,
  "PacBio" = pb_bulk.dge_human.list$AvsL.DE,
  "ONT dRNA" = drna_bulk.deg_human.list$AvsL.DE
)
p1 <- complex_upset_plot(lst)$plot + ggtitle("SCLC_A vs LUAD") + theme(plot.title = element_text(size =10))
mat.AvsL.DE <- complex_upset_plot(lst)$matrix

lst <- list(
  "Illumina" = ill_bulk.dge_human.list$PvsL.DE,
  "ONT cDNA" = ont_bulk.dge_human.list$PvsL.DE,
  "PacBio" = pb_bulk.dge_human.list$PvsL.DE,
  "ONT dRNA" = drna_bulk.deg_human.list$PvsL.DE
)
p2 <- complex_upset_plot(lst)$plot + ggtitle("SCLC_P vs LUAD") + theme(plot.title = element_text(size = 10))
mat.PvsL.DE <- complex_upset_plot(lst)$matrix

lst <- list(
  "Illumina" = ill_bulk.dge_human.list$AvsP.DE,
  "ONT cDNA" = ont_bulk.dge_human.list$AvsP.DE,
  "PacBio" = pb_bulk.dge_human.list$AvsP.DE,
  "ONT dRNA" = drna_bulk.deg_human.list$AvsP.DE
)

p3 <- complex_upset_plot(lst)$plot + ggtitle("SCLC_A vs SCLC_P") + theme(plot.title = element_text(size = 10))
mat.AvsP.DE <- complex_upset_plot(lst)$matrix
(p1 / p2 / p3) + patchwork::plot_annotation(
  title = "DGE Human",
  theme = theme(plot.title = element_text(size =15))
)
```

```{r gene: platform specific detection summary, fig.height=2, fig.width=13}
# Pivot to long format
platform_specific_gene_summary <- function(df) {
  df_long <- df %>%
  pivot_longer(-Gene, names_to = "Platform", values_to = "Detected") %>%
  group_by(Gene) %>%
  mutate(TotalDetected = sum(Detected)) %>%
  ungroup() %>%
  mutate(
    Category = case_when(
      Detected == 1 & TotalDetected == 1 ~ "Platform-Specific Detection",  # Only detected by this platform
      Detected == 0 & TotalDetected == 3 ~ "Platform-Specific Absence",      # Not detected by this platform but present elsewhere
      Detected == 1 & TotalDetected > 1 ~ "Common Detection (also detected in >0 other platform)",
      Detected == 0 & TotalDetected < 3 ~ "Common Absence (also absent in >0 other platform)" # Detected by this platform + at least one other
    )
  ) %>%
  count(Platform, Category)

# Convert to factor for proper ordering in plot
df_long$Category <- factor(df_long$Category, 
                           levels = c(
                                      "Platform-Specific Absence", 
                                      "Common Absence (also absent in >0 other platform)",
                                      "Platform-Specific Detection", 
                                      "Common Detection (also detected in >0 other platform)"
                                      ))

# Stacked bar plot
df_long %>%
  mutate(n = case_when(
    Category %in% c("Platform-Specific Absence", "Common Absence (also absent in >0 other platform)") ~ -n,
    TRUE ~ n
  )) %>%
  ggplot(aes(x = Platform, y = n, fill = Category)) +
  geom_bar(stat = "identity") +
  labs(
    y = "Number of Genes",
    x = "Platform",
    fill = "Category"
  ) +
  theme_minimal() +
  scale_fill_manual(
    values = c(
      "Platform-Specific Detection" = "#0072B2",  # Blue (color-blind friendly)
      "Platform-Specific Absence" = "#E69F00",    # Orange (color-blind friendly)
      "Common Detection (also detected in >0 other platform)" = "#009E73",  # Green
      "Common Absence (also absent in >0 other platform)" = "#999999"  # Gray
    )
  ) +
  coord_flip() +  # Flip axes for horizontal bars
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 0.5),  # Ensure x-axis labels are readable
    axis.title.x = element_text(size = 12),  # Adjust x-axis title size
    axis.text.y = element_text(size = 10)   # Adjust y-axis text size if needed
  )
}


map(list(mat.AvsL.DE, mat.PvsL.DE, mat.AvsP.DE), platform_specific_gene_summary) %>% do.call(patchwork::wrap_plots, .) +
  patchwork::plot_layout(guides = 'collect')
```

```{r}
# Save the de gene list to output_list
output_list[["AvsP.DEG.all"]] <- mat.AvsP.DE %>% 
  filter(rowSums(select(., where(is.numeric))) == 4) %>% pull(Gene)
output_list[["AvsP.DEG.any"]] <- mat.AvsP.DE %>% 
  filter(rowSums(select(., where(is.numeric))) > 0) %>% pull(Gene)

output_list[["AvsL.DEG.all"]] <- mat.AvsL.DE %>% 
  filter(rowSums(select(., where(is.numeric))) == 4) %>% pull(Gene)
output_list[["AvsL.DEG.any"]] <- mat.AvsL.DE %>% 
  filter(rowSums(select(., where(is.numeric))) > 0) %>% pull(Gene)

output_list[["PvsL.DEG.all"]] <- mat.PvsL.DE %>% 
  filter(rowSums(select(., where(is.numeric))) == 4) %>% pull(Gene)
output_list[["PvsL.DEG.any"]] <- mat.PvsL.DE %>% 
  filter(rowSums(select(., where(is.numeric))) > 0) %>% pull(Gene)
```

## More inspection on DEG human
```{r echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Get gene annotations and information
library(biomaRt)
options(timeout = 600) 
ensembl <- useEnsembl(biomart = "genes", dataset = "hsapiens_gene_ensembl")
# Query Ensembl for gene symbols and chromosome information
gene_info <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "chromosome_name"),
                   mart = ensembl)

```

### Biotype and Transcript length

Here we explore the overlap of gene sets across different sequencing platforms (Illumina, ONT cDNA, PacBio, ONT dRNA) alongside average transcript length and biotype information. From this we note that for DEGs detected across all platforms the majority are protein-coding genes- thus this subset of overlapping genes should be considered ***high-confidence DEGs***.

```{r Biotype and transcript length on DEG, echo=TRUE, fig.height=9, fig.width=15}
library(patchwork)
# Function to preprocess the data and create an upset plot
my_complexUpset <- function(data, gene_length_lookup, ensembl, title) {
  # Preprocess data
  plot_d <- data %>%
    left_join(gene_length_lookup, by = c("Gene" = "gene_id")) %>%
    rename(`Gene length` = mean_length) %>%
    mutate(Gene = sub("\\..*", "", Gene))
  
  # Retrieve biotypes using biomaRt
  biotypes <- getBM(
    attributes = c("ensembl_gene_id", "gene_biotype"),
    filters = "ensembl_gene_id",
    values = plot_d$Gene,
    mart = ensembl
  )
  
  # Integrate biotypes and process
  plot_d <- plot_d %>%
    left_join(biotypes, by = c("Gene" = "ensembl_gene_id")) %>%
    rename(biotype = gene_biotype) %>%
    mutate(
      biotype = ifelse(biotype %in% 
                         names(sort(table(biotype), decreasing = TRUE)[1:3]), 
                       biotype, "Others"),
      biotype = factor(biotype, levels = c(sort(unique(biotype)) %>% setdiff("Others"), "Others"))
    )
  
  # Generate the upset plot
  upset_plot <- ComplexUpset::upset(
  plot_d %>% mutate(
    biotype = case_when(
      biotype =="protein_coding" ~ "Protein-coding",
      TRUE ~ "Non-protein-coding"
    )
  ),
  intersect = c('Illumina', "ONT cDNA", "PacBio", "ONT dRNA"),
  annotations = list(
        # 1st method - passing list:
        "Gene length" = list(
          aes = aes(x = intersection, y = `Gene length`),
          # provide a list if you wish to add several geoms
          geom = geom_boxplot(na.rm = TRUE, outliers = FALSE)
        )
        # ,
        # "BioType" = list(
        #   aes = aes(x = intersection, fill = biotype),
        #   geom = geom_bar(position = "fill")
        # )
  ),
  base_annotations=list(
        'Intersection size'=ComplexUpset::intersection_size(
            counts=TRUE,
            mapping=aes(fill=biotype),
            text=element_text(size = 3, vjust=-0.2)
        ) + scale_fill_manual(values = c("Non-protein-coding"="#BAC5CB",
                              "Protein-coding"='#B5C952'))
    ),
  set_sizes=(
        ComplexUpset::upset_set_size(
            geom=geom_bar(
                aes(fill=biotype),
                width=0.8
            ) ,
            position='right'
        )+ scale_fill_manual(values = c("Non-protein-coding"="#BAC5CB",
                              "Protein-coding"='#B5C952')) + 
          theme(legend.position = "none")
  ),
  guides='over',
  wrap = TRUE
)
  
  return(upset_plot)
}

# Generate the gene length lookup table
tx_ref_df <- ill_bulk.dge$genes %>%
  rownames_to_column("tx_id") %>%
  select(tx_id, Length) %>%
  tibble() %>%
  mutate(
    biotype = strsplit(tx_id, "\\|") %>% sapply(function(x) x[8]),
    gene_id = strsplit(tx_id, "\\|") %>% sapply(function(x) x[2]),
    tx_id = strsplit(tx_id, "\\|") %>% sapply(function(x) x[1])
  )

gene_length_lookup <- tx_ref_df %>%
  group_by(gene_id) %>%
  summarise(mean_length = mean(Length, na.rm = TRUE), .groups = "drop")


# Generate plots using the function
plot1 <- my_complexUpset(mat.AvsL.DE, gene_length_lookup, ensembl, "SCLC_A vs LUAD")
plot2 <- my_complexUpset(mat.PvsL.DE, gene_length_lookup, ensembl, "SCLC_P vs LUAD")
plot3 <- my_complexUpset(mat.AvsP.DE, gene_length_lookup, ensembl, "SCLC_A vs SCLC_P")


# Combine plots in a 2x2 grid with one empty space
final_plot <- (plot1 + plot2) / (plot3 + plot_spacer()) + plot_layout(nrow = 2)
final_plot
```

## Inspect High-confidence DGE

### High-Confidence DGE list

Here we generate a list of high-confidence differential expressed genes for ***SCLC_A vs LUAD***, ***SCLC_P vs LUAD***, and ***SCLC_A vs SCLC_P***, which consists of the common significant genes detected for all 4 platforms.

-   ***SCLC_A vs LUAD*** csv table of genes can be inspected in [AvsL_common_DEG.csv](./DGE_tables/AvsL_common_DEG.csv)

-   ***SCLC_P vs LUAD*** csv table of genes can be inspected in [PvsL_common_DEG.csv](./DGE_tables/PvsL_common_DEG.csv)

-   ***SCLC_A vs SCLC_P*** csv table of genes can be inspected in [AvsP_common_DEG.csv](./DGE_tables/AvsP_common_DEG.csv)

```{r common and platform-specific DEGs, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# General function to extract common and platform-specific DEGs
get_DEGs <- function(DE_matrix) {
  # Common DEGs: Genes that are DE across all platforms
  common_DEGs <- DE_matrix %>%
    filter(`Illumina` == 1 & `ONT cDNA` == 1 & PacBio == 1 & `ONT dRNA` == 1) %>%
    pull(Gene)  # Extract the gene names
  
  # Platform-specific DEGs: Genes that are DE in only one platform at a time
  platform_DEGs <- list(
    Illumina_only = DE_matrix %>%
      filter(`Illumina` == 1 & `ONT cDNA` == 0 & PacBio == 0 & `ONT dRNA` == 0) %>%
      pull(Gene),
    
    ONT_cDNA_only = DE_matrix %>%
      filter(`Illumina` == 0 & `ONT cDNA` == 1 & PacBio == 0 & `ONT dRNA` == 0) %>%
      pull(Gene),
    
    PacBio_only = DE_matrix %>%
      filter(`Illumina` == 0 & `ONT cDNA` == 0 & PacBio == 1 & `ONT dRNA` == 0) %>%
      pull(Gene),
    
    ONT_dRNA_only = DE_matrix %>%
      filter(`Illumina` == 0 & `ONT cDNA` == 0 & PacBio == 0 & `ONT dRNA` == 1) %>%
      pull(Gene)
  )
  
  # Return the results
  return(list(
    common_DEGs = common_DEGs,
    platform_DEGs = platform_DEGs
  ))
}

# Using mat.AvsL.DE
DEG_results_AvsL <- get_DEGs(mat.AvsL.DE) 
# Using mat.PvsL.DE
DEG_results_PvsL <- get_DEGs(mat.PvsL.DE)
# Using mat.AvsP.DE
DEG_results_AvsP <- get_DEGs(mat.AvsP.DE)
```

```{r High-confidence DGE tables, include=FALSE}
# List of comparisons and their common DEG results
comparisons <- list(
  AvsL = DEG_results_AvsL$common_DEGs,
  PvsL = DEG_results_PvsL$common_DEGs,
  AvsP = DEG_results_AvsP$common_DEGs
)

# Platform-specific DEG tables
platforms <- list(
  Illumina = ill_bulk.dge_human.list,
  ONT_cDNA = ont_bulk.dge_human.list,
  PacBio = pb_bulk.dge_human.list,
  ONT_dRNA = drna_bulk.deg_human.list
)

# Function to filter and rename columns for a platform
filter_and_rename_columns <- function(DEG_table, common_DEGs, platform_name) {
  DEG_filtered <- DEG_table[rownames(DEG_table) %in% common_DEGs, ]
  colnames(DEG_filtered)[1:4] <- paste0(platform_name, "_", colnames(DEG_filtered)[1:4])
  return(DEG_filtered)
}

# Generalized processing for each comparison
combined_deg_tables <- lapply(names(comparisons), function(comparison) {
  # Get the common DEGs for this comparison
  common_DEGs <- comparisons[[comparison]]
  
  # Filter and rename DEG tables for all platforms
  filtered_DEG_tables <- lapply(names(platforms), function(platform) {
    DEG_table <- platforms[[platform]][[paste0(comparison, ".DE")]]$table
    filter_and_rename_columns(DEG_table, common_DEGs, platform)
  })
  
  # Combine the DEG tables for this comparison
  combined_deg_table <- do.call(cbind, filtered_DEG_tables)
  
  # Add gene info
  combined_deg_table <- combined_deg_table %>%
    rownames_to_column("gene") %>%
    mutate(ensembl_gene_id = sub("\\..*", "", gene)) %>%
    left_join(gene_info, by = "ensembl_gene_id") %>%
    relocate(ensembl_gene_id, hgnc_symbol, chromosome_name, .after = gene)
  
  return(combined_deg_table)
})

# Naming the results by comparison
names(combined_deg_tables) <- names(comparisons)
# Save individual combined DEG tables as CSV files
#write.table(combined_deg_tables$AvsL, "AvsL_common_DEG.csv", sep = ",", row.names = FALSE, col.names = TRUE)
#write.table(combined_deg_tables$PvsL, "PvsL_common_DEG.csv", sep = ",", row.names = FALSE, col.names = TRUE)
#write.table(combined_deg_tables$AvsP, "AvsP_common_DEG.csv", sep = ",", row.names = FALSE, col.names = TRUE)

```

Here we can scroll through the tables generate for high-confidence genes with the statical values from each platform comparison.

```{r html tables common DGE, echo=TRUE, message=FALSE, warning=FALSE}
library(kableExtra)
# Define the color palette with transparency
color_palette <- c(
  PacBio = "rgba(223, 25, 149, 0.3)",
  ONT_cDNA = "rgba(4, 71, 108, 0.3)",
  ONT_dRNA = "rgba(36, 205, 205, 0.3)",
  Illumina = "rgba(232, 139, 32, 0.3)"
)

# Function to map column names to colors
get_color <- function(column_name) {
  if (grepl("Gene|ensembl_gene_id|hgnc_symbol|chromosome_name", column_name)) {
    return("white")  # No color for metadata columns
  }
  if (grepl("ONT_dRNA", column_name, ignore.case = TRUE)) {
    return(color_palette["ONT_dRNA"])
  }
  if (grepl("ONT", column_name, ignore.case = TRUE)) {
    return(color_palette["ONT_cDNA"])
  }
  if (grepl("Illumina", column_name, ignore.case = TRUE)) {
    return(color_palette["Illumina"])
  }
  if (grepl("PacBio", column_name, ignore.case = TRUE)) {
    return(color_palette["PacBio"])
  }
  return("white")  # Default color
}

# Function to create an HTML table for a combined DEG table
create_html_table <- function(combined_deg_table, caption) {
  column_colors <- sapply(colnames(combined_deg_table), get_color)
  column_colors[1:4] <- "white"  # Set the first four columns' colors to white
  
  combined_deg_table %>%
    kable(format = "html", caption = caption) %>%
    kable_styling(bootstrap_options = c("striped", "hover")) %>%
    column_spec(1, bold = TRUE, background = "white") %>%  # Gene column styling
    purrr::reduce(1:ncol(combined_deg_table), function(kable_obj, col_idx) {
      kable_obj %>% column_spec(col_idx, background = column_colors[col_idx])
    }, .init = .) %>%
    scroll_box(width = "100%", height = "500px")
}

# Generate separate HTML tables for AvsL, PvsL, and AvsP
table_AvsL <- create_html_table(combined_deg_tables$AvsL, "High-confidence DGE SCLC A vs LUAD")
table_PvsL <- create_html_table(combined_deg_tables$PvsL, "High-confidence DGE SCLC P vs LUAD")
table_AvsP <- create_html_table(combined_deg_tables$AvsP, "High-confidence DGE SCLC A vs SCLC P")

# View tables in RStudio Viewer
table_AvsL
table_PvsL
table_AvsP

```

## Platform-Specific DGE

In this section we generate a list of platform-specfic differential expressed genes for ***SCLC_A vs LUAD***, ***SCLC_P vs LUAD***, and ***SCLC_A vs SCLC_P***, which consists of the unique significant genes detected for all 4 platforms.

-   ***SCLC_A vs LUAD*** csv table of genes can be inspected in [AvsL_common_DEG.csv](./DGE_summary/DGE_tables/AvsL_platform_specific_DEGs.csv)

-   ***SCLC_P vs LUAD*** csv table of genes can be inspected in [PvsL_common_DEG.csv](./DGE_summary/DGE_tables/PvsL_platform_specific_DEGs.csv)

-   ***SCLC_A vs SCLC_P*** csv table of genes can be inspected in [AvsP_common_DEG.csv](./DGE_summary/DGE_tables/AvsP_platform_specific_DEGs.csv)

```{r Platform-specific DGE, echo=TRUE}
# List of comparisons and their common DEG results
comparisons <- list(
  AvsL = DEG_results_AvsL$platform_DEGs,
  PvsL = DEG_results_PvsL$platform_DEGs,
  AvsP = DEG_results_AvsP$platform_DEGs
)

# Platform-specific DEG tables
platforms <- list(
  Illumina = ill_bulk.dge_human.list,
  ONT_cDNA = ont_bulk.dge_human.list,
  PacBio = pb_bulk.dge_human.list,
  ONT_dRNA = drna_bulk.deg_human.list
)

# Function to filter DEGs for a specific platform and add the platform column
filter_platform_specific <- function(DEG_table, specific_genes, platform_name) {
  DEG_filtered <- DEG_table[rownames(DEG_table) %in% specific_genes, ]
  if (nrow(DEG_filtered) == 0) {
    message(paste("No genes found for the platform-specific list:", platform_name))
    return(data.frame())  # Return empty data frame if no DEGs
  }
  
  # Add platform column
  DEG_filtered$platform <- platform_name
  
  return(DEG_filtered)
}

# Generalized processing for each comparison
platform_specific_deg_tables <- lapply(names(comparisons), function(comparison) {
  # Extract platform-specific gene lists for this comparison
  platform_DEGs <- comparisons[[comparison]]
  
  # Filter and add platform column for Illumina-specific DEGs
  illumina_DEG_filtered <- filter_platform_specific(
    platforms$Illumina[[paste0(comparison, ".DE")]]$table,
    platform_DEGs$Illumina_only,
    "Illumina"
  )
  
  # Filter and add platform column for ONT cDNA-specific DEGs
  ont_cDNA_DEG_filtered <- filter_platform_specific(
    platforms$ONT_cDNA[[paste0(comparison, ".DE")]]$table,
    platform_DEGs$ONT_cDNA_only,
    "ONT_cDNA"
  )
  
  # Filter and add platform column for PacBio-specific DEGs
  pacbio_DEG_filtered <- filter_platform_specific(
    platforms$PacBio[[paste0(comparison, ".DE")]]$table,
    platform_DEGs$PacBio_only,
    "PacBio"
  )
  
  # Filter and add platform column for ONT dRNA-specific DEGs
  drna_DEG_filtered <- filter_platform_specific(
    platforms$ONT_dRNA[[paste0(comparison, ".DE")]]$table,
    platform_DEGs$ONT_dRNA_only,
    "ONT_dRNA"
  )
  
  # Combine all platform-specific DEGs for this comparison
  combined_platform_DEGs <- bind_rows(
    illumina_DEG_filtered,
    ont_cDNA_DEG_filtered,
    pacbio_DEG_filtered,
    drna_DEG_filtered
  )
  
  # Add gene information if the combined table is not empty
  if (nrow(combined_platform_DEGs) > 0) {
    combined_platform_DEGs <- combined_platform_DEGs %>%
      rownames_to_column("gene") %>%
      mutate(ensembl_gene_id = sub("\\..*", "", gene)) %>%
      left_join(gene_info, by = "ensembl_gene_id") %>%
      relocate(ensembl_gene_id, hgnc_symbol, chromosome_name, .after = gene)
  }
  
  return(combined_platform_DEGs)
})

# Assign names to results by comparison
names(platform_specific_deg_tables) <- names(comparisons)

# Save the platform-specific DEG tables as CSV files
#write.csv(platform_specific_deg_tables$AvsL, "AvsL_platform_specific_DEGs.csv", row.names = FALSE)
#write.csv(platform_specific_deg_tables$PvsL, "PvsL_platform_specific_DEGs.csv", row.names = FALSE)
#write.csv(platform_specific_deg_tables$AvsP, "AvsP_platform_specific_DEGs.csv", row.names = FALSE)

```

Here we can scroll through the tables generated for platform specific genes with the statistical values from each platform comparison.

```{r HTML platform-specific DGE, echo=TRUE, message=FALSE, warning=FALSE}

# Function to assign colors based on platform
assign_color <- function(platform) {
  color_palette[platform]
}

# Function to generate the colored table for any comparison
create_platform_colored_table <- function(deg_table, caption) {
  
  # Add a colored platform column based on the platform
  colored_table <- deg_table %>%
    mutate(
      platform_color = assign_color(platform)  # Assign colors based on platform
    )
  
  # Check if the columns exist and then select them for removal
  columns_to_remove <- c("platform_color", "row_color", "row_css")
  existing_columns_to_remove <- columns_to_remove[columns_to_remove %in% colnames(colored_table)]
  
  # Render the table with the platform column colored and gene column bold
  kable(
    colored_table %>% select(-one_of(existing_columns_to_remove)),  # Dynamically remove existing columns
    format = "html",
    caption = caption,
    escape = FALSE  # Allow HTML content in the table
  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover")) %>%
    # Directly color the platform column (assuming it's column 9, adjust if necessary)
    column_spec(9, background = colored_table$platform_color) %>%
    # Make the 'gene' column (first column) bold
    column_spec(1, bold = TRUE) %>%
    scroll_box(width = "100%", height = "500px")
}

# Generate platform-specific tables for each comparison
table_AvsL <- create_platform_colored_table(platform_specific_deg_tables$AvsL, "Platform Specific DGE SCLC A vs LUAD")
table_PvsL <- create_platform_colored_table(platform_specific_deg_tables$PvsL, "Platform Specific DGE SCLC P vs LUAD")
table_AvsP <- create_platform_colored_table(platform_specific_deg_tables$AvsP, "Platform Specific DGE SCLC A vs SCLC P")

# View tables in RStudio Viewer (or render in HTML)
table_AvsL
table_PvsL
table_AvsP

```

# Check Expected DE
```{r}
expected_DE <- read_csv(params$expe)

add_FC <- function(x){
  x %>% 
  left_join(ill_bulk.dge_human.list$AvsL.DE$table %>% 
              rownames_to_column('Gene')  %>% 
              select(Gene, logFC) %>%
              mutate(
                Gene = sub("\\..*", "", Gene)
                ) %>%
              rename(
                Illumina_logFC = logFC
              ), by = "Gene") %>% 
    left_join(ont_bulk.dge_human.list$AvsL.DE$table %>% 
              rownames_to_column('Gene')  %>% 
              select(Gene, logFC) %>%
              mutate(
                Gene = sub("\\..*", "", Gene)
                ) %>%
              rename(
                ONT_cDNA_logFC = logFC
              ), by = "Gene") %>%
    left_join(pb_bulk.dge_human.list$AvsL.DE$table %>% 
              rownames_to_column('Gene')  %>% 
              select(Gene, logFC) %>%
              mutate(
                Gene = sub("\\..*", "", Gene)
                ) %>%
              rename(
                Pacbio_logFC = logFC
              ), by = "Gene") %>% 
    left_join(drna_bulk.deg_human.list$AvsL.DE$table %>% 
              rownames_to_column('Gene')  %>% 
              select(Gene, logFC) %>%
              mutate(
                Gene = sub("\\..*", "", Gene)
                ) %>%
              rename(
                ONT_dRNA_logFC = logFC
              ), by = "Gene")
}

expected_DE %>%  left_join(mat.AvsL.DE %>% mutate(Gene = sub("\\..*", "", Gene)), by="Gene") %>% add_FC
expected_DE %>% left_join(mat.PvsL.DE %>% mutate(Gene = sub("\\..*", "", Gene)), by="Gene") %>% add_FC
expected_DE %>% left_join(mat.AvsP.DE %>% mutate(Gene = sub("\\..*", "", Gene)), by="Gene") %>% add_FC

```


# Enrichment Analysis (Clusterprofiler)

In this section, **GO and KEGG enrichment analyses** are performed to identify key biological functions and pathways for differential expressed genes (DEGs).

1.  The `enrichGO()` function is used with the **"ALL" ontology** to capture biological processes, molecular functions, and cellular components.

2.  The `enrichKEGG()` function is applied to identify enriched pathways. Gene lists are filtered for DEG presence across platforms and converted to ENTREZ IDs using bitr(). Results are visualized with dot plots for GO and KEGG.

## GO Analysis

### SCLC_A vs LUAD

Here GO analysis will be preformed on common DEGs as well as PacBio specific DEGs (top platform specific in this comparison)

```{r GO SCLC_A vs LUCA, echo=TRUE, fig.height=7, fig.width=5, message=FALSE, warning=FALSE}
library(clusterProfiler)

# SCLC_A vs LUAD
DEG_results_AvsL$common_DEGs <- sub("\\..*", "", DEG_results_AvsL$common_DEGs)
# GO enrichment for shared DEGs across all platforms
go_AvsL <- enrichGO(DEG_results_AvsL$common_DEGs, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_AvsL <- dotplot(go_AvsL, showCategory = 15) + ggtitle("GO Enrichment for Shared DEGs Across All Platforms")

# Process PacBio-specific DEGs
DEG_results_AvsL$platform_DEGs$PacBio_only <- sub("\\..*", "", DEG_results_AvsL$platform_DEGs$PacBio_only)

# GO enrichment for PacBio-specific DEGs
go_AvsL_pacbio <- enrichGO(DEG_results_AvsL$platform_DEGs$PacBio_only, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_AvsL_pacbio <- dotplot(go_AvsL_pacbio, showCategory = 15) + ggtitle("GO Enrichment for PacBio-Specific DEGs")

plot_go_AvsL + plot_go_AvsL_pacbio + plot_layout(nrow = 2)

# Save the GO enrichment results for PacBio-specific DEGs as a CSV
#write.csv(as.data.frame(go_AvsL), "go_AvsL_DEGs_enrichment.csv", row.names = FALSE)
#write.csv(as.data.frame(go_AvsL_pacbio), "go_AvsL_pacbio_DEGs_enrichment.csv", row.names = FALSE)


```

Here we can factor in directionality in the gene set analysis by splitting by negative logFC (downregulated) or positive logFC (upregulated). Here due to the comparison being SCLC_A vs LUAD, if positive logFC (upregulated) this means that the genes are upregulated in SCLC_A compared to LUAD. Whereas if negative logFC (downregulated) this means the genes are downregulated in SCLC_A compared to LUAD. 

```{r include=FALSE}

classify_genes <- function(data, p_value_threshold = 0.05) {
  # Create classification for each platform using mutate and case_when
  data <- data %>%
    mutate(
      Illumina_status = case_when(
        Illumina_logFC > 0 & Illumina_PValue < p_value_threshold ~ "Upregulated",
        Illumina_logFC < 0 & Illumina_PValue < p_value_threshold ~ "Downregulated",
        TRUE ~ "Not Significant"
      ),
      ONT_cDNA_status = case_when(
        ONT_cDNA_logFC > 0 & ONT_cDNA_PValue < p_value_threshold ~ "Upregulated",
        ONT_cDNA_logFC < 0 & ONT_cDNA_PValue < p_value_threshold ~ "Downregulated",
        TRUE ~ "Not Significant"
      ),
      PacBio_status = case_when(
        PacBio_logFC > 0 & PacBio_PValue < p_value_threshold ~ "Upregulated",
        PacBio_logFC < 0 & PacBio_PValue < p_value_threshold ~ "Downregulated",
        TRUE ~ "Not Significant"
      ),
      ONT_dRNA_status = case_when(
        ONT_dRNA_logFC > 0 & ONT_dRNA_PValue < p_value_threshold ~ "Upregulated",
        ONT_dRNA_logFC < 0 & ONT_dRNA_PValue < p_value_threshold ~ "Downregulated",
        TRUE ~ "Not Significant"
      )
    )
  
  # Filter for upregulated and downregulated genes based on any platform
  upregulated_genes <- data %>%
    filter(
      Illumina_status == "Upregulated" | 
        ONT_cDNA_status == "Upregulated" | 
        PacBio_status == "Upregulated" | 
        ONT_dRNA_status == "Upregulated"
    )
  
  downregulated_genes <- data %>%
    filter(
      Illumina_status == "Downregulated" | 
        ONT_cDNA_status == "Downregulated" | 
        PacBio_status == "Downregulated" | 
        ONT_dRNA_status == "Downregulated"
    )
  
  # Return a list of upregulated and downregulated genes
  return(list(
    upregulated_genes = upregulated_genes,
    downregulated_genes = downregulated_genes
  ))
}

AvsL_DEG_split <- classify_genes(combined_deg_tables$AvsL)
PvsL_DEG_split <- classify_genes(combined_deg_tables$PvsL)
AvsP_DEG_split <- classify_genes(combined_deg_tables$AvsP)

```

```{r, echo=TRUE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}
# SCLC_A vs LUAD
# GO enrichment for shared DEGs across all platforms
go_AvsL_upreg <- enrichGO(AvsL_DEG_split$upregulated_genes$ensembl_gene_id, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_AvsL_upregulated <- dotplot(go_AvsL_upreg, showCategory = 15) + ggtitle("SCLC_A vs LUAD GO Shared DEGs (Upregulated)")


go_AvsL_downreg <- enrichGO(AvsL_DEG_split$downregulated_genes$ensembl_gene_id, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_AvsL_downregulated <- dotplot(go_AvsL_downreg, showCategory = 15) + ggtitle("SCLC_A vs LUAD GO Shared DEGs (Downregulated)")

plot_go_AvsL_upregulated + plot_go_AvsL_downregulated + plot_layout(nrow = 2)

# Save the GO enrichment results for direction as a CSV
#write.csv(as.data.frame(go_AvsL_upreg), "go_upreg_AvsL_DEGs_enrichment.csv", row.names = FALSE)
#write.csv(as.data.frame(go_AvsL_downreg), "go_downreg_AvsL_pacbio_DEGs_enrichment.csv", row.names = FALSE)


```



### SCLC_P vs LUAD

Here GO analysis will be preformed on common DEGs as well as PacBio specific DEGs (top platform specific in this comparison)

No significant GO terms found with the given p-value cutoff for PacBio specific DEGs.

```{r GO SCLC_P vs LUAD, echo=TRUE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}
# SCLC_P vs LUAD
DEG_results_PvsL$common_DEGs <- sub("\\..*", "", DEG_results_PvsL$common_DEGs)
# GO enrichment for shared DEGs across all platforms
go_PvsL <- enrichGO(DEG_results_PvsL$common_DEGs, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_PvsL <- dotplot(go_PvsL, showCategory = 15) + ggtitle("GO Enrichment for Shared DEGs Across All Platforms")

# Process PacBio-specific DEGs
DEG_results_PvsL$platform_DEGs$PacBio_only <- sub("\\..*", "", DEG_results_PvsL$platform_DEGs$PacBio_only)

# GO enrichment for PacBio-specific DEGs
go_PvsL_pacbio <- enrichGO(DEG_results_PvsL$platform_DEGs$PacBio_only, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_PvsL_pacbio <- dotplot(go_PvsL_pacbio, showCategory = 15) + ggtitle("GO Enrichment for PacBio-Specific DEGs")

plot_go_PvsL + plot_layout(nrow = 2)

# Save the GO enrichment results for PacBio-specific DEGs as a CSV
#write.csv(as.data.frame(go_PvsL), "go_PvsL_DEGs_enrichment.csv", row.names = FALSE)
#write.csv(as.data.frame(go_PvsL_pacbio), "go_PvsL_pacbio_DEGs_enrichment.csv", row.names = FALSE)

```
Here we can factor in directionality in the gene set analysis by splitting by negative logFC (downregulated) or positive logFC (upregulated). Here due to the comparison being SCLC_P vs LUAD, if positive logFC (upregulated) this means that the genes are upregulated in SCLC_P compared to LUAD. Whereas if negative logFC (downregulated) this means the genes are downregulated in SCLC_P compared to LUAD. 

```{r, echo=TRUE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}
# SCLC_P vs LUAD
# GO enrichment for shared DEGs across all platforms
go_PvsL_upreg <- enrichGO(PvsL_DEG_split$upregulated_genes$ensembl_gene_id, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_PvsL_upregulated <- dotplot(go_PvsL_upreg, showCategory = 15) + ggtitle("SCLC_P vs LUAD GO Shared DEGs (Upregulated)")


go_PvsL_downreg <- enrichGO(PvsL_DEG_split$downregulated_genes$ensembl_gene_id, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_PvsL_downregulated <- dotplot(go_PvsL_downreg, showCategory = 15) + ggtitle("SCLC_P vs LUAD GO Shared DEGs (Downregulated)")

plot_go_PvsL_upregulated + plot_go_PvsL_downregulated + plot_layout(nrow = 2)

# Save the GO enrichment results for direction as a CSV
#write.csv(as.data.frame(go_PvsL_upreg), "go_upreg_PvsL_DEGs_enrichment.csv", row.names = FALSE)
#write.csv(as.data.frame(go_PvsL_downreg), "go_downreg_PvsL_pacbio_DEGs_enrichment.csv", row.names = FALSE)

```

### SCLC_A vs SCLC_P

No significant GO terms found with the given p-value cutoff for common DEGs for SCLC_A vs SCLC_P.

Here GO analysis will be preformed on Illumina specific DEGs (top platform specific in this comparison). Note: not many common DEGs for this comparison (16). 

```{r GO SCLC_A vs SCLC_P, echo=TRUE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}

# SCLC_A vs SCLC_P
DEG_results_AvsP$common_DEGs <- sub("\\..*", "", DEG_results_AvsP$common_DEGs)
# GO enrichment for shared DEGs across all platforms
go_AvsP <- enrichGO(DEG_results_AvsP$common_DEGs, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_AvsP <- dotplot(go_AvsP, showCategory = 15) + ggtitle("GO Enrichment for Shared DEGs Across All Platforms")

# Process Illumina-specific DEGs
DEG_results_AvsP$platform_DEGs$Illumina_only <- sub("\\..*", "", DEG_results_AvsP$platform_DEGs$Illumina_only)

# GO enrichment for Illumina-specific DEGs
go_AvsP_illumina <- enrichGO(DEG_results_AvsP$platform_DEGs$Illumina_only, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_AvsP_illumina <- dotplot(go_AvsP_illumina, showCategory = 15) + ggtitle("GO Enrichment for Illumina-Specific DEGs")

# plot_go_AvsP_illumina + plot_layout(nrow = 2)

# Save the GO enrichment results for Illumina-specific DEGs as a CSV
#write.csv(as.data.frame(go_AvsP_illumina), "go_AvsP_illumina_DEGs_enrichment.csv", row.names = FALSE)

```

Here we can factor in directionality in the gene set analysis by splitting by negative logFC (downregulated) or positive logFC (upregulated). Here due to the comparison being SCLC_A vs SCLC_P, if positive logFC (upregulated) this means that the genes are upregulated in SCLC_A compared to SCLC_P. Whereas if negative logFC (downregulated) this means the genes are downregulated in SCLC_A compared to SCLC_P. 

There were 0 enriched GO terms found for Downregulated (negative logFC detected genes) for SCLC_A vs SCLC_P. 
```{r, echo=TRUE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}

# SCLC_A vs SCLC_P
# GO enrichment for shared DEGs across all platforms
go_AvsP_upreg <- enrichGO(AvsP_DEG_split$upregulated_genes$ensembl_gene_id, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_AvsP_upregulated <- dotplot(go_AvsP_upreg, showCategory = 15) + ggtitle("SCLC_A vs SCLC_P GO Shared DEGs (Upregulated)")


go_AvsP_downreg <- enrichGO(AvsP_DEG_split$downregulated_genes$ensembl_gene_id, "org.Hs.eg.db", pvalueCutoff = 0.05, keyType = "ENSEMBL", pAdjustMethod = "BH", qvalueCutoff = 0.05, ont="ALL")
plot_go_AvsP_downregulated <- dotplot(go_AvsP_downreg, showCategory = 15) + ggtitle("SCLC_A vs SCLC_P GO Shared DEGs (Downregulated)")

plot_go_AvsP_upregulated + plot_layout(nrow = 2)
```


## KEGG Analysis
### SCLC_A vs LUAD
Here we can factor in directionality in the KEGG analysis by splitting by negative logFC (downregulated) or positive logFC (upregulated). Here due to the comparison being SCLC_A vs LUAD, if positive logFC (upregulated) this means that the genes are upregulated in SCLC_A compared to LUAD. Whereas if negative logFC (downregulated) this means the genes are downregulated in SCLC_A compared to LUAD. 
```{r, echo=TRUE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}
library(org.Hs.eg.db)
# Convert upregulated genes (Ensembl -> Entrez)
upregulated_entrez <- bitr(
  AvsL_DEG_split$upregulated_genes$ensembl_gene_id,
  fromType = "ENSEMBL",
  toType = "ENTREZID",
  OrgDb = org.Hs.eg.db
)

# Convert upregulated genes (Ensembl -> Entrez)
downregulated_entrez <- bitr(
  AvsL_DEG_split$downregulated_genes$ensembl_gene_id,
  fromType = "ENSEMBL",
  toType = "ENTREZID",
  OrgDb = org.Hs.eg.db
)

# KEGG enrichment for upregulated genes
kegg_AvsL_upreg <- enrichKEGG(
  gene         = upregulated_entrez$ENTREZID,  # Use Entrez IDs
  organism     = "hsa",                        # "hsa" for human
  keyType      = "kegg",                # Specify keyType for Entrez IDs
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
  qvalueCutoff = 0.05
)

# KEGG enrichment for upregulated genes
kegg_AvsL_downreg <- enrichKEGG(
  gene         = downregulated_entrez$ENTREZID,  # Use Entrez IDs
  organism     = "hsa",                        # "hsa" for human
  keyType      = "kegg",                # Specify keyType for Entrez IDs
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
  qvalueCutoff = 0.05
)

# Plot KEGG enrichment results 
plot_kegg_AvsL_upregulated <- dotplot(kegg_AvsL_upreg, showCategory = 15) +
  ggtitle("SCLC_A vs LUAD KEGG Shared DEGs (Upregulated)")

plot_kegg_AvsL_downregulated <- dotplot(kegg_AvsL_downreg, showCategory = 15) +
  ggtitle("SCLC_A vs LUAD KEGG Shared DEGs (Downregulated)")

plot_kegg_AvsL_upregulated + plot_kegg_AvsL_downregulated + plot_layout(nrow = 2)

#Save csv 
#write.csv(as.data.frame(kegg_AvsL_upreg), "kegg_upreg_AvsL_DEGs_enrichment.csv", row.names = FALSE)
#write.csv(as.data.frame(kegg_AvsL_downreg), "kegg_downreg_AvsL_pacbio_DEGs_enrichment.csv", row.names = FALSE)


```

### SCLC_P vs LUAD

Here we can factor in directionality in the KEGG analysis by splitting by negative logFC (downregulated) or positive logFC (upregulated). Here due to the comparison being SCLC_P vs LUAD, if positive logFC (upregulated) this means that the genes are upregulated in SCLC_P compared to LUAD. Whereas if negative logFC (downregulated) this means the genes are downregulated in SCLC_P compared to LUAD. 

There were 0 enriched terms found for Upregulated (positive logFC detected genes) for SCLC_P vs LUAD. 

```{r, echo=TRUE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}

upregulated_entrez <- bitr(
  PvsL_DEG_split$upregulated_genes$ensembl_gene_id,
  fromType = "ENSEMBL",
  toType = "ENTREZID",
  OrgDb = org.Hs.eg.db
)

# Convert upregulated genes (Ensembl -> Entrez)
downregulated_entrez <- bitr(
  PvsL_DEG_split$downregulated_genes$ensembl_gene_id,
  fromType = "ENSEMBL",
  toType = "ENTREZID",
  OrgDb = org.Hs.eg.db
)

# KEGG enrichment for upregulated genes
kegg_PvsL_upreg <- enrichKEGG(
  gene         = upregulated_entrez$ENTREZID,  # Use Entrez IDs
  organism     = "hsa",                        # "hsa" for human
  keyType      = "ncbi-geneid",                # Specify keyType for Entrez IDs
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
  qvalueCutoff = 0.05
)

# KEGG enrichment for upregulated genes
kegg_PvsL_downreg <- enrichKEGG(
  gene         = downregulated_entrez$ENTREZID,  # Use Entrez IDs
  organism     = "hsa",                        # "hsa" for human
  keyType      = "ncbi-geneid",                # Specify keyType for Entrez IDs
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
  qvalueCutoff = 0.05
)

# Plot KEGG enrichment results 
plot_kegg_PvsL_upregulated <- dotplot(kegg_PvsL_upreg, showCategory = 15) +
  ggtitle("SCLC_P vs LUAD KEGG Shared DEGs (Upregulated)")

plot_kegg_PvsL_downregulated <- dotplot(kegg_PvsL_downreg, showCategory = 15) +
  ggtitle("SCLC_P vs LUAD KEGG Shared DEGs (Downregulated)")

# plot_kegg_PvsL_downregulated + plot_layout(nrow = 2)

#write.csv(as.data.frame(kegg_PvsL_upreg), "kegg_upreg_PvsL_DEGs_enrichment.csv", row.names = FALSE)
#write.csv(as.data.frame(kegg_PvsL_downreg), "kegg_downreg_PvsL_pacbio_DEGs_enrichment.csv", row.names = FALSE)


```

### SCLC_A vs SCLC_P

There were 0 enriched terms found for Upregulated (positive logFC detected genes) for SCLC_A vs SCLC_P. 
There were 0 enriched terms found for Downregulated (negative logFC detected genes) for SCLC_A vs SCLC_P. 

```{r, echo=TRUE, fig.height=15, fig.width=10, message=FALSE, warning=FALSE}

upregulated_entrez <- bitr(
  AvsP_DEG_split$upregulated_genes$ensembl_gene_id,
  fromType = "ENSEMBL",
  toType = "ENTREZID",
  OrgDb = org.Hs.eg.db
)

# Convert upregulated genes (Ensembl -> Entrez)
downregulated_entrez <- bitr(
  AvsP_DEG_split$downregulated_genes$ensembl_gene_id,
  fromType = "ENSEMBL",
  toType = "ENTREZID",
  OrgDb = org.Hs.eg.db
)

# KEGG enrichment for upregulated genes
kegg_AvsP_upreg <- enrichKEGG(
  gene         = upregulated_entrez$ENTREZID,  # Use Entrez IDs
  organism     = "hsa",                        # "hsa" for human
  keyType      = "ncbi-geneid",                # Specify keyType for Entrez IDs
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
  qvalueCutoff = 0.05
)

# KEGG enrichment for upregulated genes
kegg_AvsP_downreg <- enrichKEGG(
  gene         = downregulated_entrez$ENTREZID,  # Use Entrez IDs
  organism     = "hsa",                        # "hsa" for human
  keyType      = "ncbi-geneid",                # Specify keyType for Entrez IDs
  pvalueCutoff = 0.05,
  pAdjustMethod = "BH",
  qvalueCutoff = 0.05
)

# Plot KEGG enrichment results 
#plot_kegg_AvsP_upregulated <- dotplot(kegg_AvsP_upreg, showCategory = 15) +
  #ggtitle("SCLC_A vs LUAD KEGG Shared DEGs (Upregulated)")

#plot_kegg_AvsP_downregulated <- dotplot(kegg_AvsP_downreg, showCategory = 15) +
  #ggtitle("SCLC_A vs LUAD KEGG Shared DEGs (Downregulated)")

#plot_kegg_AvsP_downregulated + plot_layout(nrow = 2)

```


## Hallmark Analysis

Here we use MSigDB Hallmark Gene Sets with GSEA because: 1. Hallmark gene sets include curated, cancer-relevant pathways (e.g., EMT, angiogenesis, immune response, proliferation). 

### SCLC_A vs LUAD
```{r , echo=TRUE, fig.height=8, fig.width=10, message=FALSE, warning=FALSE}
library(msigdbr)
# Load MSigDB Hallmark pathways
hallmark <- msigdbr(species = "Homo sapiens", category = "H")

# Ensure your ranked genes are formatted properly
ranked_genes <- combined_deg_tables$AvsL %>%
  filter(!is.na(hgnc_symbol), hgnc_symbol != "") %>%        
  select(hgnc_symbol, Illumina_logFC) %>% 
  arrange(desc(Illumina_logFC)) %>%      
  deframe()                           

# Perform GSEA
gsea_results <- GSEA(
  geneList = ranked_genes, 
  TERM2GENE = hallmark[, c("gs_name", "gene_symbol")], 
  pvalueCutoff = 0.05,
  verbose = FALSE
)

# Plot GSEA results
dotplot(gsea_results, showCategory = 15) + 
  ggtitle("GSEA Hallmark Pathway Enrichment SCLC_A vs LUAD")

# save results 
#write.csv(as.data.frame(gsea_results), "gsea_AvsP_DEGs_enrichment.csv", row.names = FALSE)
```
Splitting for directionality leads to no significant pathways found with the given p-value cutoff.

### SCLC_P vs LUAD

No significant pathways found with the given p-value cutoff.

### SCLC_A vs SCLC_P
No significant pathways found with the given p-value cutoff.

# Differential transcript expression

## DTE edgeR (Salmon and Oarfish)

DTE analysis is performed on subsets for human genes and sequins, each with potentially different library size distributions compared to the entire dataset. To ensure consistency:

1.  The transcript level counts are scaled by the the dispersion values recovered from Gibbs sampling (50 Gibbs sampling run for each sample)

2.  Filter by Expression: Lowly expressed genes are filtered using `filterByExpr` for each subset.

3.  Normalization: Gene counts are normalized using the `calcNormFactors` function in edgeR with the `TMM` method for each subset.

4.  Differential Expression: Differential expression is assessed using a GLM-based model with the `glmQLFit` and `glmQLFTest` functions, comparing:

-   SCLC type a vs. LUAD
-   SCLC type p vs. LUAD
-   SCLC type a vs. SCLC type p

```{r echo=TRUE, message=FALSE, warning=FALSE}
DTE.edgeR_human <- function(dge, norm.method="TMM") {
  # QC and normalisation:
  filter <- filterByExpr(dge, group=dge$samples$group, min.count=5)
  dge <- dge[filter, , keep.lib.sizes = FALSE]

  if (!is.null(norm.method)) {
     dge <- calcNormFactors(dge, method = norm.method)
  }

  design <- model.matrix(~0+group, data = dge$samples)
  dge <- estimateDisp(dge, design)
  qlfit <- glmQLFit(dge, design)
  
  contrasts <- makeContrasts(
    AvsL = groupsclc_a - groupluad,
    PvsL = groupsclc_p - groupluad,
    AvsP = groupsclc_a - groupsclc_p,
    levels = design
  )
  
  AvsL.QLF.test <- glmQLFTest(qlfit, contrast = contrasts[, "AvsL"])
  PvsL.QLF.test <- glmQLFTest(qlfit, contrast = contrasts[, "PvsL"])
  AvsP.QLF.test <- glmQLFTest(qlfit, contrast = contrasts[, "AvsP"])
  
  list(
    AvsL.DE = AvsL.QLF.test,
    PvsL.DE = PvsL.QLF.test,
    AvsP.DE = AvsP.QLF.test 
  )
  
}

```

## DTE edgeR+scaling

```{r get dte scaling, echo=TRUE, message=FALSE, warning=FALSE}
# scale
ill_bulk.scale_dge <- ill_bulk.dge
ont_bulk.scale_dge <- ont_bulk.dge.oarfish
pb_bulk.scale_dge <- pb_bulk.dge.oarfish
ont_drna.scale_dge <- ont_drna.dge.oarfish

ill_bulk.scale_dge$counts  <- ill_bulk.scale_dge$counts / ill_bulk.scale_dge$genes$Overdispersion
ont_bulk.scale_dge$counts  <- ont_bulk.scale_dge$counts / ont_bulk.scale_dge$genes$Overdispersion
pb_bulk.scale_dge$counts  <- pb_bulk.scale_dge$counts / pb_bulk.scale_dge$genes$Overdispersion
ont_drna.scale_dge$counts  <- ont_drna.scale_dge$counts / ont_drna.scale_dge$genes$Overdispersion

# get human list
ill_bulk.scl_dte_human.list <- DTE.edgeR_human(ill_bulk.scale_dge[is.human(ill_bulk.scale_dge),])
ont_bulk.scl_dte_human.list <- DTE.edgeR_human(ont_bulk.scale_dge[is.human(ont_bulk.scale_dge),])
pb_bulk.scl_dte_human.list <- DTE.edgeR_human(pb_bulk.scale_dge[is.human(pb_bulk.scale_dge),])
drna_bulk.scl_dte_human.list <- DTE.edgeR_human(ont_drna.scale_dge[is.human(ont_drna.scale_dge),])


```
Here the platform specific DTE analysis can be further inspected via Glimma reports:
1.  ***SCLC type a vs. LUAD:***
/
    -   [Illumina](./DTE_summary/DTE_Glimma_HTML/Illumina_AvsL_volcano_plot.html)
    -   [PacBio](./DTE_summary/DTE_Glimma_HTML/PacBio_AvsL_volcano_plot.html)
    -   [ONT cDNA](./DTE_summary/DTE_Glimma_HTML/ONT_AvsL_volcano_plot.html)
    -   [ONT dRNA](./DTE_summary/DTE_Glimma_HTML/dRNA_AvsL_volcano_plot.html)
2.  ***SCLC type p vs. LUAD:***
/
    -   [Illumina](./DTE_summary/DTE_Glimma_HTML/Illumina_PvsL_volcano_plot.html)
    -   [PacBio](./DTE_summary/DTE_Glimma_HTML/PacBio_PvsL_volcano_plot.html)
    -   [ONT cDNA](./DTE_summary/DTE_Glimma_HTML/ONT_PvsL_volcano_plot.html)
    -   [ONT dRNA](./DTE_summary/DTE_Glimma_HTML/dRNA_PvsL_volcano_plot.html)
3.  ***SCLC type a vs. SCLC type p:***
/
    -   [Illumina](./DTE_summary/DTE_Glimma_HTML/Illumina_AvsP_volcano_plot.html)
    -   [PacBio](./DTE_summary/DTE_Glimma_HTML/PacBio_AvsP_volcano_plot.html)
    -   [ONT cDNA](./DTE_summary/DTE_Glimma_HTML/ONT_AvsP_volcano_plot.html)
    -   [ONT dRNA](./DTE_summary/DTE_Glimma_HTML/dRNA_AvsP_volcano_plot.html)

## Cross-platform comparison DTE human (upset)

Here the differential transcript expression (DTE) results visualized in the upset plots show:

1.  ***SCLC_A vs LUAD:*** 444 shared differential expressed transcripts across all platforms. Highlighting platform-specific contributions to DTE detection with largest intersections from PacBio (2181 transcripts).

2.  ***SCLC_P vs LUAD:*** The total number of differential expressed transcripts is smaller compared to SCLC_A vs LUAD. Only 45 shared differential expressed transcripts across all platforms. Highlighting platform-specific contributions to DTE detection with largest intersections from PacBio (291 transcripts).

3.  ***SCLC_A vs SCLC_P:*** A significantly smaller number of transcripts show shared differential expressed genes across all platforms (1 transcript). Highlighting platform-specific contributions to DTE detection with largest intersections from Illumina (41 transcripts).

\***Overall, the results suggest:** PacBio tends to identify highest number of platform-specific differential expressed transcripts.

```{r upset plot dte human edgeR with scaling, echo=TRUE, fig.height=10, fig.width=8, message=FALSE, warning=FALSE}

# Upset plot
## SCLC_A vs LUCA (AvsL)
lst <- list(
  "Illumina" = ill_bulk.scl_dte_human.list$AvsL.DE,
  "ONT cDNA" = ont_bulk.scl_dte_human.list$AvsL.DE,
  "PacBio" = pb_bulk.scl_dte_human.list$AvsL.DE,
  "ONT dRNA" = drna_bulk.scl_dte_human.list$AvsL.DE
)
p1 <- complex_upset_plot(lst)$plot + ggtitle("SCLC_A vs LUCA") + theme(plot.title = element_text(size = 20))
mat.AvsL.DTE <- complex_upset_plot(lst)$matrix

lst <- list(
  "Illumina" = ill_bulk.scl_dte_human.list$PvsL.DE,
  "ONT cDNA" = ont_bulk.scl_dte_human.list$PvsL.DE,
  "PacBio" = pb_bulk.scl_dte_human.list$PvsL.DE,
  "ONT dRNA" = drna_bulk.scl_dte_human.list$PvsL.DE
)
p2 <- complex_upset_plot(lst)$plot + ggtitle("SCLC_P vs LUCA") + theme(plot.title = element_text(size = 20))
mat.PvsL.DTE <- complex_upset_plot(lst)$matrix


lst <- list(
  "Illumina" = ill_bulk.scl_dte_human.list$AvsP.DE,
  "ONT cDNA" = ont_bulk.scl_dte_human.list$AvsP.DE,
  "PacBio" = pb_bulk.scl_dte_human.list$AvsP.DE,
  "ONT dRNA" = drna_bulk.scl_dte_human.list$AvsP.DE
)

p3 <- complex_upset_plot(lst)$plot + ggtitle("SCLC_A vs SCLC_P") + theme(plot.title = element_text(size = 20))
mat.AvsP.DTE <- complex_upset_plot(lst)$matrix

p1 / p2 / p3 + patchwork::plot_annotation(
  title = "DTE Human (with scaling)",
  theme = theme(plot.title = element_text(size =25))
)
```

```{r transcript: platform specific detection summary, fig.height=2, fig.width=13}
# Pivot to long format
platform_specific_gene_summary <- function(df) {
  df_long <- df %>%
  pivot_longer(-Gene, names_to = "Platform", values_to = "Detected") %>%
  group_by(Gene) %>%
  mutate(TotalDetected = sum(Detected)) %>%
  ungroup() %>%
  mutate(
    Category = case_when(
      Detected == 1 & TotalDetected == 1 ~ "Platform-Specific Detection",  # Only detected by this platform
      Detected == 0 & TotalDetected == 3 ~ "Platform-Specific Absence",      # Not detected by this platform but present elsewhere
      Detected == 1 & TotalDetected > 1 ~ "Common Detection (also detected in >0 other platform)",
      Detected == 0 & TotalDetected < 3 ~ "Common Absence (also absent in >0 other platform)" # Detected by this platform + at least one other
    )
  ) %>%
  count(Platform, Category)

# Convert to factor for proper ordering in plot
df_long$Category <- factor(df_long$Category, 
                           levels = c(
                                      "Platform-Specific Absence", 
                                      "Common Absence (also absent in >0 other platform)",
                                      "Platform-Specific Detection", 
                                      "Common Detection (also detected in >0 other platform)"
                                      ))

# Stacked bar plot
df_long %>%
  mutate(n = case_when(
    Category %in% c("Platform-Specific Absence", "Common Absence (also absent in >0 other platform)") ~ -n,
    TRUE ~ n
  )) %>%
  ggplot(aes(x = Platform, y = n, fill = Category)) +
  geom_bar(stat = "identity") +
  labs(
    y = "Number of Transcripts",
    x = "Platform",
    fill = "Category"
  ) +
  theme_minimal() +
  scale_fill_manual(
    values = c(
      "Platform-Specific Detection" = "#0072B2",  # Blue (color-blind friendly)
      "Platform-Specific Absence" = "#E69F00",    # Orange (color-blind friendly)
      "Common Detection (also detected in >0 other platform)" = "#009E73",  # Green
      "Common Absence (also absent in >0 other platform)" = "#999999"  # Gray
    )
  ) +
  coord_flip() +  # Flip axes for horizontal bars
  theme(
    axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 0.5),  # Ensure x-axis labels are readable
    axis.title.x = element_text(size = 12),  # Adjust x-axis title size
    axis.text.y = element_text(size = 10)   # Adjust y-axis text size if needed
  )
}


map(list(mat.AvsL.DTE, mat.PvsL.DTE, mat.AvsP.DTE), platform_specific_gene_summary) %>% do.call(patchwork::wrap_plots, .) +
  patchwork::plot_layout(guides = 'collect')
```

```{r}
# Save the de gene list to output_list
output_list[["AvsP.DTE.all"]] <- mat.AvsP.DTE %>% 
  filter(rowSums(select(., where(is.numeric))) == 4) %>% pull(Gene)
output_list[["AvsP.DTE.any"]] <- mat.AvsP.DTE %>% 
  filter(rowSums(select(., where(is.numeric))) > 0) %>% pull(Gene)

output_list[["AvsL.DTE.all"]] <- mat.AvsL.DTE %>% 
  filter(rowSums(select(., where(is.numeric))) == 4) %>% pull(Gene)
output_list[["AvsL.DTE.any"]] <- mat.AvsL.DTE %>% 
  filter(rowSums(select(., where(is.numeric))) > 0) %>% pull(Gene)

output_list[["PvsL.DTE.all"]] <- mat.PvsL.DTE %>% 
  filter(rowSums(select(., where(is.numeric))) == 4) %>% pull(Gene)
output_list[["PvsL.DTE.any"]] <- mat.PvsL.DTE %>% 
  filter(rowSums(select(., where(is.numeric))) > 0) %>% pull(Gene)
#

# output the rds
dir.create(dirname(params$output_rds), recursive = TRUE, showWarnings = FALSE)
saveRDS(output_list, params$output_rds)
```

## Inspect High-confidence DTE

### High-Confidence DTE list

Here we generate a list of high-confidence differential expressed transcripts for ***SCLC_A vs LUAD***, ***SCLC_P vs LUAD***, and ***SCLC_A vs SCLC_P***, which consists of the common significant transcripts detected for all 4 platforms.

-   ***SCLC_A vs LUAD*** csv table of transcripts can be inspected in [AvsL_common_DTE.csv](./DTE_tables/AvsL_common_DTE.csv)

-   ***SCLC_P vs LUAD*** csv table of transcripts can be inspected in [PvsL_common_DTE.csv](./DTE_tables/PvsL_common_DTE.csv)

-   ***SCLC_A vs SCLC_P*** csv table of transcripts can be inspected in [AvsP_common_DTE.csv](./DTE_tables/AvsP_common_DTE.csv)

```{r common and platform-specific DTEs, echo=TRUE, message=FALSE, warning=FALSE}
# Using mat.AvsL.DE
DTE_results_AvsL <- get_DEGs(mat.AvsL.DTE) 
# Using mat.PvsL.DE
DTE_results_PvsL <- get_DEGs(mat.PvsL.DTE)
# Using mat.AvsP.DE
DTE_results_AvsP <- get_DEGs(mat.AvsP.DTE)
```

### High-Confidence DTE

```{r Platform common DTE, echo=TRUE, message=FALSE, warning=FALSE}
# Comparisons for DTE Results
comparisons <- list(
  AvsL = DTE_results_AvsL$common_DEGs,
  PvsL = DTE_results_PvsL$common_DEGs,
  AvsP = DTE_results_AvsP$common_DEGs
)

# Platform-specific DTE tables
platforms <- list(
  Illumina = ill_bulk.scl_dte_human.list,
  ONT_cDNA = ont_bulk.scl_dte_human.list,
  PacBio = pb_bulk.scl_dte_human.list,
  ONT_dRNA = drna_bulk.scl_dte_human.list
)

# Function to filter and rename columns for a platform (no annotations)
filter_and_rename_columns <- function(DTE_table, common_DEGs, platform_name) {
  DTE_filtered <- DTE_table[rownames(DTE_table) %in% common_DEGs, ]
  colnames(DTE_filtered)[1:4] <- paste0(platform_name, "_", colnames(DTE_filtered)[1:4])
  return(DTE_filtered)
}

# Generalized processing for each comparison
combined_dte_tables <- lapply(names(comparisons), function(comparison) {
  # Get the common DEGs for this comparison
  common_DEGs <- comparisons[[comparison]]
  
  # Filter and rename DTE tables for all platforms
  filtered_DTE_tables <- lapply(names(platforms), function(platform) {
    DTE_table <- platforms[[platform]][[paste0(comparison, ".DE")]]$table
    filter_and_rename_columns(DTE_table, common_DEGs, platform)
  })
  
  # Combine the DTE tables for this comparison
  combined_dte_table <- do.call(cbind, filtered_DTE_tables)
  
  # Add gene as a column without additional annotations
  combined_dte_table <- combined_dte_table %>%
    rownames_to_column("gene")
  
  return(combined_dte_table)
})

# Naming the results by comparison
names(combined_dte_tables) <- names(comparisons)

# Save individual combined DTE tables as CSV files
#write.table(combined_dte_tables$AvsL, "AvsL_common_DTE.csv", sep = ",", row.names = FALSE, col.names = TRUE)
#write.table(combined_dte_tables$PvsL, "PvsL_common_DTE.csv", sep = ",", row.names = FALSE, col.names = TRUE)
#write.table(combined_dte_tables$AvsP, "AvsP_common_DTE.csv", sep = ",", row.names = FALSE, col.names = TRUE)

```

Here we can scroll through the tables generate for high-confidence transcripts with the statistical values from each platform comparison.

```{r HTML dte tables, echo=TRUE, message=FALSE, warning=FALSE}

# Function to create an HTML table for a combined DEG table
create_html_table <- function(combined_deg_table, caption) {
  column_colors <- sapply(colnames(combined_deg_table), get_color)
  column_colors[1] <- "white"  # Set the first four columns' colors to white
  
  combined_deg_table %>%
    kable(format = "html", caption = caption) %>%
    kable_styling(bootstrap_options = c("striped", "hover")) %>%
    column_spec(1, bold = TRUE, background = "white") %>%  # Gene column styling
    purrr::reduce(1:ncol(combined_deg_table), function(kable_obj, col_idx) {
      kable_obj %>% column_spec(col_idx, background = column_colors[col_idx])
    }, .init = .) %>%
    scroll_box(width = "100%", height = "500px")
}

# Generate separate HTML tables for AvsL, PvsL, and AvsP
table_AvsL <- create_html_table(combined_dte_tables$AvsL, "High-confidence DTE SCLC A vs LUAD")
table_PvsL <- create_html_table(combined_dte_tables$PvsL, "High-confidence DTE SCLC P vs LUAD")
table_AvsP <- create_html_table(combined_dte_tables$AvsP, "High-confidence DTE SCLC A vs SCLC P")

# View tables in RStudio Viewer
table_AvsL
table_PvsL
table_AvsP
```

---
title: "Longbench Quantification analysis"
author: "Yupei"
version: "v4.0"
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_float: yes
    number_sections: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: '4'
params:
  random_seed: 2024
  cache_dir: NULL
  fig.path: NULL
  input_DGEobject_rds: "/vast/projects/LongBench/analysis/workflow/rmarkdown/RDS/bulk_DGE.obj.rds"
  Tx2Gene.map.rds: "/vast/projects/LongBench/analysis/workflow/rmarkdown/RDS/Tx2Gene.map.rds"
  sequins_tsv: '/vast/projects/LongBench/reference_files/Sequin_resources/v2.4/rnasequin_isoforms_2.4.tsv'
  sirv_csv: '/home/users/allstaff/you.yu/LongBench/reference_files/SIRV_Set4_Norm_Sequences_20210507/SIRV_set4_concentration.csv'
  log2FC_cutoff: 0
---

# Setup: Create DGE from input
```{r setup, include=FALSE}
if (!is.null(params$cache_dir)) {
  knitr::opts_chunk$set(cache = TRUE, fig.width = 7, fig.height=5, warning = F, cache.path = params$cache_dir)
} else {
  knitr::opts_chunk$set(cache = FALSE, fig.width = 7, fig.height=5, warning = F)
}

knitr::opts_chunk$set(
  cache = !is.null(params$cache_dir),  # Enable caching only if cache_dir is provided
  fig.width = 15,                     # Set default figure width
  fig.height = 10,                    # Set default figure height
  warning = FALSE,                    # Suppress warnings in the output
  fig.path = params$fig.path,         # Set figure path (NULL if not provided)
  dev = if (!is.null(params$fig.path)) c("png", "svg") else NULL  # Set output devices if fig.path is provided
)

# Set cache.path only if params$cache_dir is not NULL
if (!is.null(params$cache_dir)) {
  knitr::opts_chunk$set(cache.path = params$cache_dir)
}
```

```{r Libraries,include=FALSE}
library(limma)
library(edgeR)
library(tidyverse)
library(RColorBrewer)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(glue)
library(ggplot2)
library(gridExtra)
library(ggExtra)
library(knitr)
library(rtracklayer)
library(scales)
library(patchwork)

# setup some conflict functions
rename <- dplyr::rename
select <- dplyr::select
```

```{r function for splitting the transcript origin}
is.sequins <- function(dge) {grepl("^R", rownames(dge))}
is.human <- function(dge) {grepl("^ENS", rownames(dge))}
is.sirv_or_ercc <- function(dge) {!is.human(dge) & !is.sequins(dge)} # thie is the whole SIRV set4 (ERCC + SIRV E0 + Long SIRV)
is.sirv_E0 <- function(dge) {grepl("^SIRV\\d{3}$", rownames(dge))} 
is.sirv_all <- function(dge) {grepl("^SIRV", rownames(dge))} # including all SIRV E0 and Long SIRV
is.long_sirv <- function(dge) {grepl("^SIRV\\d{4}", rownames(dge))}
is.ercc <- function(dge) {!is.human(dge) & !is.sequins(dge) & !is.sirv_all(dge)}
```

```{r color code, include=FALSE}
color_palette <- c(
  PacBio = "#df1995",
  "ONT dRNA" = "#00789b",
  "ONT cDNA" = "#04476c",
  Illumina = "#e88b20"
)
```

# Get the count data from RDS

```{r Get the count data, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
list2env(readRDS(params$input_DGEobject_rds), .GlobalEnv)
# This will load the following DGE objects:
# ill_bulk.tx.dge, ont_bulk.tx.dge, pb_bulk.tx.dge, drna_bulk.tx.dge, for transcript level unfiltered DGE
# ill_bulk.gene.dge, ont_bulk.gene.dge, pb_bulk.gene.dge, drna_bulk.gene.dge for gene level unfiltered DGE


list2env(readRDS(params$Tx2Gene.map.rds), .GlobalEnv)
# This will load 
# "SIRV.G.Tx.map"  "sequins.G.Tx.map" "human.G.Tx.map"  
```

# Part1: Identification analysis:
Before the quantification comparison, it's important to first comparison how much difference in the set of features captured by different protocols. Here I use `filterByExpr` to filter out gene/transcript with low expression.

## Analysis: Raw count distribution (Before any filtering)
```{r Raw count distribution oarfish, echo=F,fig.width=8, fig.height=3}
plot_raw_count <- function(filter_func, title, legend = TRUE) {
  plot_df <- data.frame(
    "Illumina" = ill_bulk.tx.dge[filter_func(ill_bulk.tx.dge), ]$counts %>% sum(),
    "ONT cDNA" = ont_bulk.tx.dge[filter_func(ont_bulk.tx.dge), ]$counts %>% sum(),
    "ONT dRNA" = drna_bulk.tx.dge[filter_func(drna_bulk.tx.dge), ]$counts %>% sum(),
    "PacBio" = pb_bulk.tx.dge[filter_func(pb_bulk.tx.dge), ]$counts %>% sum(),
    check.names = FALSE
  ) %>% pivot_longer(everything(), names_to = "Dataset", values_to = "Total Count")

  p <- ggplot(plot_df, aes(x = Dataset, y = `Total Count` / 1000000, fill = Dataset)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    theme_minimal() +
    labs(title = title, x = "Datasets", y = "Total Count (Million)") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    # change fill color scheme
    scale_fill_manual(values = color_palette[c("Illumina", "ONT cDNA", "ONT dRNA", "PacBio")] %>% unname())
  
  if (legend) {
    p <- p + theme(legend.position = "bottom")
  } else {
    p <- p + theme(legend.position = "none")
  }
  p
}

p1 <- plot_raw_count(is.human, "Human transcript", legend=FALSE)
p2 <- plot_raw_count(is.sequins, "Sequins transcript", legend=TRUE)
p3 <- plot_raw_count(is.sirv_all, "SIRV transcript", legend = FALSE)
p4 <- plot_raw_count(is.ercc, "ERCC transcript", legend = FALSE)

(p1 | p2 | p3 | p4) +
  patchwork::plot_layout(
    guides = "collect"
  ) & theme(legend.position = "bottom") &
  patchwork::plot_annotation(
    title = "Total transcript counts",
    theme = theme(plot.title = element_text(hjust = 0.5))
  )
```

# Analysis: Comparison of Overdispesion

```{r Overdispersion stratified by number, fig.height=8, fig.width=10}
overdisp_boxplot <- function(filter_func, title, breaks= c(0,1,5,10,20,40, Inf), legend=TRUE) {
  ## human
  ill_bulk.tx.dge.filtered <-  ill_bulk.tx.dge[filter_func(ill_bulk.tx.dge),]
  ont_bulk.tx.dge.filtered <- ont_bulk.tx.dge[filter_func(ont_bulk.tx.dge),]
  pb_bulk.tx.dge.filtered <- pb_bulk.tx.dge[filter_func(pb_bulk.tx.dge), ]
  drna_bulk.tx.dge.filtered <- drna_bulk.tx.dge[filter_func(drna_bulk.tx.dge),]

  tx_map_d <- rbind(human.G.Tx.map, sequins.G.Tx.map, SIRV.G.Tx.map)

  overdisp_d <- data.frame(
    "ONT cDNA" = ont_bulk.tx.dge.filtered$genes$Overdispersion,
    Illumina = ill_bulk.tx.dge.filtered$genes$Overdispersion[match(rownames(ont_bulk.tx.dge.filtered), rownames(ill_bulk.tx.dge.filtered))],
    PacBio = pb_bulk.tx.dge.filtered$genes$Overdispersion[match(rownames(ont_bulk.tx.dge.filtered), rownames(pb_bulk.tx.dge.filtered))],
    "ONT dRNA" = drna_bulk.tx.dge.filtered$genes$Overdispersion[match(rownames(ont_bulk.tx.dge.filtered), rownames(drna_bulk.tx.dge.filtered$genes))],
    tx_count = tx_map_d$tx_count[match(rownames(ont_bulk.tx.dge.filtered) %>% sub("\\|.*", "", .), tx_map_d$tx_name)],
    check.names = FALSE
  )
  overdisp_d$tx_count_bin <- cut(overdisp_d$tx_count, breaks = breaks)
  overdisp_d$tx_count_bin <- factor(overdisp_d$tx_count_bin, ordered = TRUE)
  overdisp_d_pivot <- pivot_longer(overdisp_d, 
                              cols = c("ONT cDNA", PacBio, "ONT dRNA", Illumina), 
                              names_to = "Method", values_to = "Overdispersion") %>%
                      mutate(DataType=factor(
                              case_when(Method=="Illumina" ~ "Short read",
                                        TRUE ~ "Long read"),
                              levels = c("Short read", "Long read")
                              )
                             )
  p <- ggplot(overdisp_d_pivot, aes(x = tx_count_bin, y = Overdispersion, fill = DataType, color = DataType)) +
    geom_boxplot(position = position_dodge(width = 0.75), outliers = FALSE) +
    scale_y_continuous(limits = c(1, NA)) + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = title, x = "Transcript number", y = "Overdispersion") +
    theme_minimal() +
    scale_fill_manual(values = c( color_palette["Illumina"], "#909291") %>% unname()) +
    scale_color_manual(values = c("#666666", "#000000"))

  
  if (legend) {
    p <- p + theme(legend.position = "right")
  } else {
    p <- p + theme(legend.position = "none")
  }
  rst <- list(
    all_data = p
  )

  overdisp_d <- pivot_longer(overdisp_d, 
                            cols = c("ONT cDNA", PacBio, "ONT dRNA"), 
                            names_to = "Method", values_to = "Overdispersion")

  p <- ggplot(overdisp_d, aes(x = tx_count_bin, y = Overdispersion, fill = Method)) +
    geom_boxplot(position = position_dodge(width = 0.75), outliers = FALSE) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(title = paste(title, "(Long read datasets)"), x = "Number of transcripts per gene", y = "Overdispersion") +
    scale_fill_manual(values = color_palette[c("ONT cDNA", "ONT dRNA", "PacBio")] %>% unname()) +
    scale_y_continuous(limits = c(1, NA)) + 
    theme_minimal()
  if (legend) {
    p <- p + theme(legend.position = "right")
  } else {
    p <- p + theme(legend.position = "none")
  }
  rst$long_only <- p

  rst
}

p1 <- overdisp_boxplot(is.human, "Human transcript", legend = TRUE)
p2 <- overdisp_boxplot(function(x) {is.sequins(x) | is.sirv_or_ercc(x)}, breaks= c(0,1,3,10,20, Inf), title = "Spike-ins", legend = TRUE)


{
  (p1$all_data + theme(legend.position = "none") | p2$all_data) /
    (p1$long_only + theme(legend.position = "none") | p2$long_only)
} + patchwork::plot_annotation(
  title = "Overdispersion stratified by transcript number",
  theme = theme(plot.title = element_text(hjust = 0.5))
)

```
## Filter by commonly identified features
### 2. Filter out lowly expressed genes and transcript using `filterByExpr` for each dataset, using min.count=5 for tx parameters

```{r transcript filtering for DE}
# Transcript
## 1. get common transcripts
common_tx <- Reduce(intersect, lapply(list(ill_bulk.tx.dge, ont_bulk.tx.dge, pb_bulk.tx.dge, drna_bulk.tx.dge), rownames))

ill_bulk.tx.dge <- ill_bulk.tx.dge[common_tx, ]
ont_bulk.tx.dge <- ont_bulk.tx.dge[common_tx, ]
pb_bulk.tx.dge <- pb_bulk.tx.dge[common_tx, ]
drna_bulk.tx.dge <- drna_bulk.tx.dge[common_tx, ]

# ## 2. filter by expression
keep <- filterByExpr(ill_bulk.tx.dge, group = ill_bulk.tx.dge$samples$group, min.count=5) &
          filterByExpr(ont_bulk.tx.dge, group = ont_bulk.tx.dge$samples$group, min.count=5) &
          filterByExpr(pb_bulk.tx.dge, group = pb_bulk.tx.dge$samples$group, min.count=5) &
          filterByExpr(drna_bulk.tx.dge, group = drna_bulk.tx.dge$samples$group, min.count=5)
table(keep)

ill_bulk.tx.dge <- ill_bulk.tx.dge[keep, ]
ont_bulk.tx.dge <- ont_bulk.tx.dge[keep, ]
pb_bulk.tx.dge <- pb_bulk.tx.dge[keep, ]
drna_bulk.tx.dge <- drna_bulk.tx.dge[keep, ]
```

# Analysis: Raw count vs Transcript length scatter

## Normalisation function
```{r}
# Normalisation functions
get_tpm <- function(dge) {
    counts <- dge$counts
    len <- dge$gene$EffectiveLength
    stopifnot(length(len) == nrow(counts))
    tpm <- apply(counts, 2, function(col) {
      rpk <- col / len
      rpk / sum(rpk) * 1e6
    })
    
  return(tpm)
  }
  
get_tpm_raw_txlength <- function(dge) {
    counts <- dge$counts
    len <- dge$gene$Length
    stopifnot(length(len) == nrow(counts))
    tpm <- apply(counts, 2, function(col) {
      rpk <- col / len
      rpk / sum(rpk) * 1e6
    })
    
  return(tpm)
}

# Add EffectiveLength to long-read data to make it compatible with tpm function
ont_bulk.tx.dge$genes$EffectiveLength <- 1
drna_bulk.tx.dge$genes$EffectiveLength <- 1
pb_bulk.tx.dge$genes$EffectiveLength <- 1
```


```{r Raw count vs Transcript length scatter(human), fig.height=10, fig.width=10}
plot_raw_count_vs_length <- function(dge, title, filter_func=is.human, cpm.norm=FALSE) {
  dge <- dge[filter_func(dge), ]
   plot_d <- tibble(
    Length = rep(dge$genes$Length, times = ncol(dge$counts)) %>% log10,  # Replicate Length values for each sample
    Sample = rep(colnames(dge$counts), each = nrow(dge$counts)),  # Repeat sample names for each gene
    counts = if(cpm.norm) {cpm(dge$counts ,log=T) %>% as.vector} else log10(as.vector(dge$counts)) # Flatten counts into a vector and take log10, 0 will go to -Inf
  ) %>%
    filter(counts > 0)

  # Add regression line with confidence interval and correlation
  p <- ggplot(plot_d %>% slice_sample(n = 1000), aes(x = Length, y = counts)) +
    geom_point(alpha=0.3) +
    geom_smooth(method = "lm", se = TRUE, color = "blue", linewidth = 1) +  # Add regression line with CI
    theme_minimal() +
    labs(title = title, x = "Transcript length (log10)", y = if(cpm.norm) "logCPM" else "Raw count (log10)")

  # Calculate Pearson and Spearman correlation
  pearson_cor <- cor(plot_d$Length, plot_d$counts, method = "pearson")  # Pearson correlation
  spearman_cor <- cor(plot_d$Length, plot_d$counts, method = "spearman")  # Spearman correlation
  
  # Annotate both Pearson and Spearman correlation values on the plot
  p <- p + annotate("text", x = Inf, y = Inf, label = paste0("R (Pearson) = ", round(pearson_cor, 4), "\nR (Spearman) = ", round(spearman_cor, 4)), 
                    hjust = 1.1, vjust = 2, size = 5)

  p
}

common_tx <- Reduce(intersect, lapply(list(ill_bulk.tx.dge, ont_bulk.tx.dge, pb_bulk.tx.dge, drna_bulk.tx.dge), rownames))
p1 <- plot_raw_count_vs_length(ill_bulk.tx.dge[common_tx,], "Illumina")
ill_bulk.tx.dge.tmp <- ill_bulk.tx.dge[common_tx, ]
p1.tpm <- plot_raw_count_vs_length(  {
    x <- ill_bulk.tx.dge[common_tx, ]
    x$counts <- get_tpm(x)
    x
  },
 "Illumina Length-adjusted (Salmon Effective Length)") + ylab("log10(TPM)") +
  scale_x_continuous()
p1.tpm.raw.tx.len <- plot_raw_count_vs_length(  {
    x <- ill_bulk.tx.dge[common_tx, ]
    x$counts <- get_tpm_raw_txlength(x)
    x
  },
 "Illumina Length-adjusted (Raw tx length)")  + ylab("log10(TPM)") +
  scale_x_continuous()
p2 <- plot_raw_count_vs_length(ont_bulk.tx.dge[common_tx,], "ONT cDNA")
p2.tpm <- plot_raw_count_vs_length({
    x <- ont_bulk.tx.dge[common_tx,]
    x$counts <- get_tpm(x)
    x
  }, "ONT cDNA Length-adjusted")
p3 <- plot_raw_count_vs_length(pb_bulk.tx.dge[common_tx,], "PacBio")
p3.tpm <- plot_raw_count_vs_length({
    x <- pb_bulk.tx.dge[common_tx,]
    x$counts <- get_tpm(x)
    x
  }, "PacBio Length-adjusted")
p4 <- plot_raw_count_vs_length(drna_bulk.tx.dge[common_tx,], "ONT dRNA")
p4.tpm <- plot_raw_count_vs_length({
    x <- drna_bulk.tx.dge[common_tx,]
    x$counts <- get_tpm(x)
    x
  }, "ONT dRNA Length-adjusted")

grid.arrange(p1, p1.tpm, p2, p3, p4, ncol=2, top = "human transcripts")
```
## SIRV + long SIRV
```{r Raw count vs Transcript length scatter(SIRV), fig.height=10, fig.width=10}

p1 <- plot_raw_count_vs_length(ill_bulk.tx.dge[common_tx,], "Illumina" ,filter_func=is.sirv_all)
ill_bulk.tx.dge.tmp <- ill_bulk.tx.dge[common_tx, ]
p1.tpm <- plot_raw_count_vs_length(  {
    x <- ill_bulk.tx.dge[common_tx, ]
    x$counts <- get_tpm(x)
    x
  },
 "Illumina Length-adjusted (Salmon Effective length)",filter_func=is.sirv_all) +
  ylab("log10(TPM)") +
  scale_x_continuous()
p1.tpm.raw.tx.len <- plot_raw_count_vs_length(  {
    x <- ill_bulk.tx.dge[common_tx, ]
    x$counts <- get_tpm_raw_txlength(x)
    x
  },
 "Illumina Length-adjusted (Raw tx length)",filter_func=is.sirv_all) +
  ylab("log10(TPM)") +
  scale_x_continuous()
p2 <- plot_raw_count_vs_length(ont_bulk.tx.dge[common_tx,], "ONT cDNA",filter_func=is.sirv_all, cpm.norm = T) + ylim(0,18)
p3 <- plot_raw_count_vs_length(pb_bulk.tx.dge[common_tx,], "PacBio",filter_func=is.sirv_all, cpm.norm = T)+ ylim(0,18)
p4 <- plot_raw_count_vs_length(drna_bulk.tx.dge[common_tx,], "ONT dRNA",filter_func=is.sirv_all, cpm.norm = T)+ ylim(0,18)
grid.arrange(p1, p1.tpm , p1.tpm.raw.tx.len, p2, p3, p4, ncol=3)
```
# Spike in quantification
## PLOT: Spike-in transcript length distribution
```{r, fig.height=3, fig.width=3}
# sequins transcript length
sequins.gt <- read_tsv(params$sequins_tsv)

# Prepare data
seq_d <- data.frame(LENGTH = sequins.gt$LENGTH, type = "Sequins")
ercc_d <- data.frame(LENGTH = ont_bulk.tx.dge[is.ercc(ont_bulk.tx.dge),]$genes$Length, type = "ERCC")
sirv_d <- data.frame(LENGTH = ont_bulk.tx.dge[is.sirv_E0(ont_bulk.tx.dge),]$genes$Length, type = "SIRV E0")
sirv_long_d <- data.frame(LENGTH = ont_bulk.tx.dge[is.long_sirv(ont_bulk.tx.dge),]$genes$Length, type = "long SIRV")

# Combine and set factor levels
plot_d <- rbind(seq_d, ercc_d, sirv_d, sirv_long_d)
plot_d$type <- factor(plot_d$type, levels = c("Sequins", "ERCC", "SIRV E0", "long SIRV"))

# Plot
library(ggplot2)
p <- ggplot(plot_d, aes(x = type, y = LENGTH, fill = type)) +
  geom_boxplot(outlier.size = 0.5) +
  scale_y_continuous(limits = c(0, 10000)) +
  labs(title = "Transcript Length Distributions", x = "Transcript Type", y = "Transcript Length") +
  theme_minimal() +
  theme(legend.position = "none") + 
  scale_fill_viridis_d(option="D")  +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  

p

plot_d %>%
  group_by(type) %>%
  summarise(
    q0 = quantile(LENGTH, 0, na.rm = TRUE),
    q25 = quantile(LENGTH, 0.25, na.rm = TRUE),
    q50 = quantile(LENGTH, 0.5, na.rm = TRUE),
    q75 = quantile(LENGTH, 0.75, na.rm = TRUE),
    q100 = quantile(LENGTH, 1, na.rm = TRUE)
  )
```

## Sequins (Scatter plot of expected vs observed)
```{r Sequins scatter, fig.width=12, fig.height=3}
get_sequins_scatter_plot <- function(dge, figure_name, tx_len_norm = TRUE) {

    dge <- dge[is.sequins(dge),]
    dge.sequins <- dge[is.sequins(dge),]

    # Normalisation functions
    get_ltpm <- function(counts,len) {
        x <- counts/len
        get_lcpm(x)
    }

    get_lcpm <- function(x) { 
        return(log2(x*1e6/sum(x) + 1))
    }
    
    # Prepare Sequins ground truth
    sequins.gt <- read_tsv(params$sequins_tsv)
    sequins.gt.norm <- sequins.gt %>% mutate(across(starts_with("MIX"), get_lcpm)) %>% select(NAME, MIX_A, MIX_B, LENGTH) %>% mutate(N_transcript_per_gene = gsub("^R.*_", "", NAME) %>% as.numeric)
    
    # Normalise observed data
    if (tx_len_norm) {
        dge.sequins.norm <- dge.sequins$counts %>% as_tibble(rownames="NAME")  %>% mutate(across(where(is.numeric), ~ get_ltpm(.x, dge.sequins$gene$EffectiveLength)))
    } else {
        dge.sequins.norm <- dge.sequins$counts %>% as_tibble(rownames="NAME")  %>% mutate(across(where(is.numeric), get_lcpm))
    }
    dge.sequins.norm  <- dge.sequins.norm %>% left_join(dge.sequins$gene %>% as_tibble(rownames="NAME") %>% select(NAME))

    # Merge the ground truth and observed data
    mixA_df <-dge.sequins.norm %>% select(-dge.sequins$samples$sample[dge.sequins$samples$sequins=='B']) %>% left_join(sequins.gt.norm)  %>% 
          mutate(GT=MIX_A, MIX='A')  %>% 
          select(-MIX_B, -MIX_A)
    mixB_df <- dge.sequins.norm %>% select(-dge.sequins$samples$sample[dge.sequins$samples$sequins=='A']) %>% left_join(sequins.gt.norm) %>% 
      mutate(GT=MIX_B, MIX='B')  %>% 
      select(-MIX_B, -MIX_A)
    
    mixA_df.long <- mixA_df %>% pivot_longer(cols = mixA_df %>% select(dge.sequins$samples$sample[dge.sequins$samples$sequins=='A']) %>% colnames, names_to = "Sample", values_to = "Observed log-CPM")
    mixB_df.long <- mixB_df %>% pivot_longer(cols = mixB_df %>% select(dge.sequins$samples$sample[dge.sequins$samples$sequins=='B']) %>% colnames, names_to = "Sample", values_to = "Observed log-CPM")
    combined_df <- rbind(mixA_df.long, mixB_df.long)
    
    per_sample_cor <- sapply(dge$samples$sample, function(x) {
      cor(combined_df[combined_df$Sample == x,]$GT, combined_df[combined_df$Sample == x,]$`Observed log-CPM`) %>% unlist
    })
    
    # Calculate the correlation
    combined_df$Sample <- factor(combined_df$Sample)
    combined_df$MIX <- factor(combined_df$MIX)
    correlation <- cor(combined_df$GT, combined_df$`Observed log-CPM`)
    mean_sq_error <- mean((combined_df$GT - combined_df$`Observed log-CPM`)^2)
    mean_abs_error <- mean(abs(combined_df$GT - combined_df$`Observed log-CPM`))
    
    combined_df <- combined_df %>% mutate(N_transcript_per_gene = N_transcript_per_gene %>% as.factor(), `Transcript length` = LENGTH)
    # color by the quantile of the transcript length
    combined_df$`Transcript length` <- cut(combined_df$`Transcript length`, 
                                                      breaks = quantile(combined_df$`Transcript length`, 
                                                      probs = seq(0, 1, 0.25)), 
                                                      include.lowest = TRUE,
                                                      labels = c("1st Quartile", "2nd Quartile", "3rd Quartile", "4th Quartile"))

     p2 <- ggplot(combined_df[rownames(combined_df) %>% sample(nrow(combined_df), replace = F),], aes(y = GT, x = `Observed log-CPM`, color = `Transcript length`)) +
      geom_point() +
      geom_abline(slope = 1, intercept = 0, linetype = "dotted") +  # Add a dotted line of x=y
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      theme_classic() + 
      # scale_y_log10(labels = label_number()) + 
      labs(title = figure_name, y = "Expected abundance log2(TPM+1)", x = "Observed log2(TPM+1)") +
      annotate("text", x = 10, y = 5, 
               label = paste("Correlation: ", round(correlation, 2),'\n'
                             ,"MSE: ", round(mean_sq_error, 2),'\n'
                             ,"MAE: ", round(mean_abs_error, 2)),
               hjust = 0, vjust = 1, 
               color = "black", size =3, 
               fontface = "italic") +
      scale_color_viridis_d() +
      scale_size_continuous(limits = c(0, 5)) +
       xlim(0,20) +
       ylim(0,20)
    
    t <- tibble(
      sample = dge$samples$sample,
      sample_correlation = per_sample_cor,
      merged_correlation = correlation
    )
    return(list(plot2 = p2, table = t))
}


# Salmon and Oarfish
cor.ill_bulk <- get_sequins_scatter_plot(ill_bulk.tx.dge, figure_name = "Illumina", tx_len_norm = TRUE)
cor.pb_bulk.oarfish <- get_sequins_scatter_plot(pb_bulk.tx.dge, figure_name = "PacBio", tx_len_norm = FALSE)
cor.ONT_dRNA.oarfish <- get_sequins_scatter_plot(drna_bulk.tx.dge, figure_name = "ONT dRNA", tx_len_norm = FALSE)
cor.ont_bulk.oarfish <- get_sequins_scatter_plot(ont_bulk.tx.dge, figure_name = "ONT cDNA", tx_len_norm = FALSE)


list(
  cor.ill_bulk$plot2,
  cor.ont_bulk.oarfish$plot2,
  cor.ONT_dRNA.oarfish$plot2,
  cor.pb_bulk.oarfish$plot2
) %>% patchwork::wrap_plots(ncol = 4, guides = "collect")
```

### Plot: Combine quantiled states
```{r Plot: Combine quantiled states (Squins), fig.height=3, fig.width=10 }
get_sequin_quartiled_states <- function(dge, sample_name, tx_len_norm = TRUE) {
  dge <- dge[is.sequins(dge), ]
  dge.sequins <- dge[is.sequins(dge), ]

  # Normalisation functions
  get_ltpm <- function(counts, len) {
    x <- counts / len
    get_lcpm(x)
  }

  get_lcpm <- function(x) {
    return(log2(x * 1e6 / sum(x) + 1))
  }

  # Prepare Sequins ground truth
  sequins.gt <- read_tsv(params$sequins_tsv)
  sequins.gt.norm <- sequins.gt %>%
    mutate(across(starts_with("MIX"), get_lcpm)) %>%
    select(NAME, MIX_A, MIX_B, LENGTH) %>%
    mutate(N_transcript_per_gene = gsub("^R.*_", "", NAME) %>% as.numeric())

  # Normalise observed data
  if (tx_len_norm) {
    dge.sequins.norm <- dge.sequins$counts %>%
      as_tibble(rownames = "NAME") %>%
      mutate(across(where(is.numeric), ~ get_ltpm(.x, dge.sequins$genes$EffectiveLength)))
  } else {
    dge.sequins.norm <- dge.sequins$counts %>%
      as_tibble(rownames = "NAME") %>%
      mutate(across(where(is.numeric), get_lcpm))
  }
  dge.sequins.norm <- dge.sequins.norm %>% left_join(dge.sequins$gene %>% as_tibble(rownames = "NAME") %>% select(NAME))

  # Merge the ground truth and observed data
  mixA_df <- dge.sequins.norm %>%
    select(-dge.sequins$samples$sample[dge.sequins$samples$sequins == "B"]) %>%
    left_join(sequins.gt.norm) %>%
    mutate(GT = MIX_A, MIX = "A") %>%
    select(-MIX_B, -MIX_A)
  mixB_df <- dge.sequins.norm %>%
    select(-dge.sequins$samples$sample[dge.sequins$samples$sequins == "A"]) %>%
    left_join(sequins.gt.norm) %>%
    mutate(GT = MIX_B, MIX = "B") %>%
    select(-MIX_B, -MIX_A)

  mixA_df.long <- mixA_df %>% pivot_longer(cols = mixA_df %>% select(dge.sequins$samples$sample[dge.sequins$samples$sequins == "A"]) %>% colnames(), names_to = "Sample", values_to = "Observed log-CPM")
  mixB_df.long <- mixB_df %>% pivot_longer(cols = mixB_df %>% select(dge.sequins$samples$sample[dge.sequins$samples$sequins == "B"]) %>% colnames(), names_to = "Sample", values_to = "Observed log-CPM")
  combined_df <- rbind(mixA_df.long, mixB_df.long)

  per_sample_cor <- sapply(dge$samples$sample, function(x) {
    cor(combined_df[combined_df$Sample == x, ]$GT, combined_df[combined_df$Sample == x, ]$`Observed log-CPM`) %>% unlist()
  })
  per_sample_mse <- sapply(dge$samples$sample, function(x) {
    mean((combined_df[combined_df$Sample == x, ]$GT - combined_df[combined_df$Sample == x, ]$`Observed log-CPM`)^2) %>% unlist()
  })

  # Calculate the correlation
  combined_df$Sample <- factor(combined_df$Sample)
  combined_df$MIX <- factor(combined_df$MIX)
  # correlation <- cor(combined_df$GT, combined_df$`Observed log-CPM`)
  # mean_sq_error <- mean((combined_df$GT - combined_df$`Observed log-CPM`)^2)
  # mean_abs_error <- mean(abs(combined_df$GT - combined_df$`Observed log-CPM`))

  combined_df <- combined_df %>% mutate(N_transcript_per_gene = N_transcript_per_gene %>% as.factor(), `Transcript length` = LENGTH)
  # color by the quantile of the transcript length
  combined_df$`Transcript length` <- cut(combined_df$`Transcript length`, 
                                                    breaks = quantile(combined_df$`Transcript length`, 
                                                    probs = seq(0, 1, 0.25)), 
                                                    include.lowest = TRUE,
                                                    labels = c("1st Quartile", "2nd Quartile", "3rd Quartile", "4th Quartile"))

                                              

  # calculate the correlation per quartile and per sample, and also give the correlation overall all four quartiles
  per_quartile_cor <- combined_df %>%
    group_by(Sample, `Transcript length`) %>%
    summarise(correlation = cor(GT, `Observed log-CPM`)) %>%
    rename(
      cell_line = Sample
    ) %>%
    ungroup()
  
  per_quartile_mse <- combined_df %>%
    group_by(Sample, `Transcript length`) %>%
    summarise(mean_sq_error = mean((GT - `Observed log-CPM`)^2)) %>%
    rename(
      cell_line = Sample
    ) %>%
    ungroup()

  # merge the overall correlation with the per quartile correlation
  per_sample_cor <- tibble(
    cell_line = names(per_sample_cor),
    new_correlation = as.numeric(per_sample_cor)
  )
  per_sample_mse <- tibble(
    cell_line = names(per_sample_mse),
    new_mean_sq_error = as.numeric(per_sample_mse)
  )

  # Combine the two tibbles
  combined_data <- per_quartile_cor %>%
    left_join(per_quartile_mse, by = c("cell_line", "Transcript length")) %>%
    rename('mean square error' = mean_sq_error)
  # Add "All transcript" row with the new correlations
  all_transcripts <- per_sample_cor %>%
    left_join(per_sample_mse, by = "cell_line") %>%
    mutate(`Transcript length` = "All transcript") %>%
    rename(correlation = new_correlation,   "mean square error" = new_mean_sq_error)

  # Combine with the original data
  combined_data <- bind_rows(combined_data, all_transcripts)
  combined_data$sample <- sample_name
  combined_data
}


cor.ont_bulk <- get_sequin_quartiled_states(ont_bulk.tx.dge, sample_name="ONT cDNA" ,tx_len_norm = FALSE)
cor.pb_bulk <- get_sequin_quartiled_states(pb_bulk.tx.dge, sample_name = "PacBio", tx_len_norm = FALSE)
cor.ONT_dRNA <- get_sequin_quartiled_states(drna_bulk.tx.dge, sample_name = "ONT dRNA", tx_len_norm = FALSE)
cor.ill_bulk <- get_sequin_quartiled_states(ill_bulk.tx.dge, sample_name = "Illumina", tx_len_norm = TRUE)

plot_df <- rbind(cor.ont_bulk, cor.pb_bulk, cor.ONT_dRNA, cor.ill_bulk)

# get_stats_comparison
## start a one column tibble called total counts
dge_list <- list(
  'ONT cDNA' = ont_bulk.tx.dge,
  PacBio = pb_bulk.tx.dge,
  "ONT dRNA" = drna_bulk.tx.dge,
  Illumina = ill_bulk.tx.dge
) %>%  lapply(function(x) {
  x[is.sequins(x), ]
})
  
total_counts <- tibble(
  sample = lapply(names(dge_list), function(x) {rep(x, nrow(dge_list[[x]]$samples))}) %>% unlist,
  cell_line = lapply(dge_list, function(x) {x$samples$sample}) %>% unlist,
  total_counts = lapply(dge_list, function(x) {x$counts %>% colSums()}) %>% unlist,
  Transcript_discovery = lapply(dge_list, function(x) {
     x$counts %>% apply(2, function(x) {
       mean(x > 0)
     })
  }) %>% unlist
)



plot_df <- plot_df %>% left_join(total_counts, by = c("cell_line", "sample"))


# working
plot_df$cell_line_sample <- paste(plot_df$sample, plot_df$cell_line, sep = " - ")
# order the cell line sample level first by the sample then by the cell line
plot_df$cell_line_sample <- factor(plot_df$cell_line_sample, levels = plot_df$cell_line_sample %>% unique() %>% sort())

```


```{r Plot: Combine quantiled boxplot (Squins), fig.height=2, fig.width=7 }
ggplot(plot_df, aes(x = sample, y = `mean square error`, colour = sample)) +
  geom_boxplot() +
  facet_wrap(~ `Transcript length`,  ncol = 5) +
  theme_minimal() +
  scale_color_manual(values = color_palette) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Samples", y = "mean square error")
```

## ERCC
```{r ERCC scatter, fig.width=12, fig.height=3}
get_ercc_scatter_plot <- function(dge, figure_name, tx_len_norm = TRUE) {
    dge.ercc <- dge[is.sirv_or_ercc(dge) & !is.sirv_all(dge),]

    # Normalisation functions
    get_ltpm <- function(counts,len) {
        x <- counts/len
        get_lcpm(x)
    }

    get_lcpm <- function(x) { 
        return(log2(x*1e6/sum(x) + 1))
    }
    
    # Prepare Sequins ground truth
    ercc.gt <- read_csv(params$sirv_csv) %>% filter(grepl("ERCC", txid))
    ercc.gt.norm <- ercc.gt %>% mutate(GT=get_lcpm(conc), NAME=GenBank, Length=dge.ercc$genes$Length[match(GenBank, rownames(dge.ercc))]) %>% select(NAME, GT, Length)
    
    # Normalise observed data
    if (tx_len_norm) {
        dge.ercc.norm <- dge.ercc$counts %>% as_tibble(rownames="NAME")  %>% mutate(across(where(is.numeric), ~ get_ltpm(.x, dge.ercc$genes$EffectiveLength)))
    } else {
        dge.ercc.norm <- dge.ercc$counts %>% as_tibble(rownames="NAME")  %>% mutate(across(where(is.numeric), get_lcpm))
    }
    dge.ercc.norm  <- dge.ercc.norm %>% left_join(dge.ercc$gene %>% as_tibble(rownames="NAME") %>% select(NAME))

    # Merge the ground truth and observed data
    df <-dge.ercc.norm %>% left_join(ercc.gt.norm)
    
    combined_df <- df %>% pivot_longer(cols = dge.ercc$samples$sample, names_to = "Sample", values_to = "Observed log-CPM")
    
    per_sample_cor <- sapply(dge$samples$sample, function(x) {
      cor(combined_df[combined_df$Sample == x, ]$GT, combined_df[combined_df$Sample == x, ]$`Observed log-CPM`) %>% unlist()
    })


    # Calculate the correlation
    combined_df$Sample <- factor(combined_df$Sample)
    correlation <- cor(combined_df$GT, combined_df$`Observed log-CPM`)
    mean_sq_error <- mean((combined_df$GT - combined_df$`Observed log-CPM`)^2)
    mean_abs_error <- mean(abs(combined_df$GT - combined_df$`Observed log-CPM`))
    
    combined_df <- combined_df %>% rename("Transcript length" = Length)

    # color by the quantile of the transcript length
    combined_df$`Transcript length` <- cut(combined_df$`Transcript length`, 
                                                      breaks = quantile(combined_df$`Transcript length`, 
                                                      probs = seq(0, 1, 0.25)), 
                                                      include.lowest = TRUE,
                                                      labels = c("1st Quartile", "2nd Quartile", "3rd Quartile", "4th Quartile"))

    #p2 <- ggplot(combined_df[rownames(combined_df) %>% sample(nrow(combined_df), replace = F),], aes(y = GT, x = `Observed log-CPM`, color = `Transcript length quartiles`, shape = N_transcript_per_gene, size = Overdispersion)) +
     p2 <- ggplot(combined_df[rownames(combined_df) %>% sample(nrow(combined_df), replace = F),], aes(y = GT, x = `Observed log-CPM`, color = `Transcript length`)) +
      geom_point() +
      geom_abline(slope = 1, intercept = 0, linetype = "dotted") +  # Add a dotted line of x=y
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      theme_classic() + 
      # scale_y_log10(labels = label_number()) + 
      labs(title = figure_name, y = "Expected abundance log2(TPM+1)", x = "Observed log2(TPM+1)") +
      annotate("text", x = 15, y = 12, 
               label = paste("r = ", round(correlation, 2)),
               hjust = 0, vjust = 1, 
               color = "black", size = 3, 
               fontface = "italic") +
      scale_color_viridis_d() +
      scale_size_continuous(limits = c(0, 5)) +
      xlim(10,20) +
       ylim(10,20)
    
    t <- tibble(
      sample = dge$samples$sample,
      sample_correlation = per_sample_cor,
      merged_correlation = correlation
    )
    return(list(plot1 = p1,  plot2 = p2, table = t))
}

cor.ont_bulk <- get_ercc_scatter_plot(ont_bulk.tx.dge, figure_name = "ONT cDNA ", tx_len_norm = FALSE)
cor.pb_bulk <- get_ercc_scatter_plot(pb_bulk.tx.dge, figure_name = "PacBio ", tx_len_norm = FALSE)
cor.ONT_dRNA <- get_ercc_scatter_plot(drna_bulk.tx.dge, figure_name = "ONT dRNA ", tx_len_norm = FALSE)
cor.ill_bulk <- get_ercc_scatter_plot(ill_bulk.tx.dge, figure_name = "Illumina ", tx_len_norm = TRUE)



plot_df <- cor.ont_bulk$table %>% dplyr::rename(`ONT Bulk`=sample_correlation) %>% 
            left_join(cor.ill_bulk$table %>% dplyr::rename(`Illumina Bulk`=sample_correlation), by = 'sample') %>% 
            left_join(cor.pb_bulk$table %>% dplyr::rename(`PacBio Bulk`=sample_correlation), by = 'sample') %>% 
            left_join(cor.ONT_dRNA$table %>% dplyr::rename(`ONT dRNA`=sample_correlation), by = 'sample') %>%
            select(`ONT Bulk`, `ONT dRNA`, `PacBio Bulk`, `Illumina Bulk`) %>% 
            pivot_longer(col=c(`ONT Bulk`, `ONT dRNA`, `PacBio Bulk`, `Illumina Bulk`), values_to = "correlation", names_to = "Sample")

bx_plot <- ggplot(plot_df, aes(x = Sample, y = correlation, fill = Sample)) +
  geom_boxplot(position = position_dodge(width = 0.75)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "ERCC transcript: per sample correlation with true abundance")

list(
  cor.ill_bulk$plot2,
  cor.ont_bulk$plot2,
  cor.ONT_dRNA$plot2,
  cor.pb_bulk$plot2) %>% patchwork::wrap_plots(ncol = 4, guides = "collect")

```

```{r, fig.width=10, fig.height=10}
get_ercc_quartiled_states <- function(dge, sample_name, tx_len_norm = TRUE) {
  dge.ercc <- dge[is.sirv_or_ercc(dge) & !is.sirv_all(dge), ]

  # Normalisation functions
  get_ltpm <- function(counts, len) {
    x <- counts / len
    get_lcpm(x)
  }

  get_lcpm <- function(x) {
    return(log2(x * 1e6 / sum(x) + 1))
  }

  # Prepare Sequins ground truth
  ercc.gt <- read_csv(params$sirv_csv) %>% filter(grepl("ERCC", txid))
  ercc.gt.norm <- ercc.gt %>%
    mutate(GT = get_lcpm(conc), NAME = GenBank, Length = dge.ercc$genes$Length[match(GenBank, rownames(dge.ercc))]) %>%
    select(NAME, GT, Length)

  # Normalise observed data
  if (tx_len_norm) {
    dge.ercc.norm <- dge.ercc$counts %>%
      as_tibble(rownames = "NAME") %>%
      mutate(across(where(is.numeric), ~ get_ltpm(.x, dge.ercc$genes$EffectiveLength)))
  } else {
    dge.ercc.norm <- dge.ercc$counts %>%
      as_tibble(rownames = "NAME") %>%
      mutate(across(where(is.numeric), get_lcpm))
  }
  dge.ercc.norm <- dge.ercc.norm %>% left_join(dge.ercc$gene %>% as_tibble(rownames = "NAME") %>% select(NAME))

  # Merge the ground truth and observed data
  df <- dge.ercc.norm %>% left_join(ercc.gt.norm)

  combined_df <- df %>% pivot_longer(cols = dge.ercc$samples$sample, names_to = "Sample", values_to = "Observed log-CPM")

  per_sample_cor <- sapply(dge$samples$sample, function(x) {
    cor(combined_df[combined_df$Sample == x, ]$GT, combined_df[combined_df$Sample == x, ]$`Observed log-CPM`) %>% unlist()
  })
  per_sample_mse <- sapply(dge$samples$sample, function(x) {
      mean((combined_df[combined_df$Sample == x, ]$GT - combined_df[combined_df$Sample == x, ]$`Observed log-CPM`)^2) %>% unlist()
  })
    

  # Calculate the correlation
  combined_df$Sample <- factor(combined_df$Sample)
  correlation <- cor(combined_df$GT, combined_df$`Observed log-CPM`)

  combined_df <- combined_df %>% rename( "Transcript length" = Length)

  # color by the quantile of the transcript length
  combined_df$`Transcript length` <- cut(combined_df$`Transcript length`,
    breaks = quantile(combined_df$`Transcript length`,
      probs = seq(0, 1, 0.25)
    ),
    include.lowest = TRUE,
    labels = c("1st Quartile", "2nd Quartile", "3rd Quartile", "4th Quartile")
  )

  # calculate the correlation per quartile and per sample, and also give the correlation overall all four quartiles
  per_quartile_cor <- combined_df %>%
    group_by(Sample, `Transcript length`) %>%
    summarise(correlation = cor(GT, `Observed log-CPM`)) %>%
    rename(
      "cell_line" = Sample
    ) %>%
    ungroup()

  per_quartile_mse <- combined_df %>%
    group_by(Sample, `Transcript length`) %>%
    summarise(mean_sq_error = mean((GT - `Observed log-CPM`)^2)) %>%
    rename(
      "cell_line" = Sample
    ) %>%
    ungroup()

  # merge the overall correlation with the per quartile correlation
  per_sample_cor <- tibble(
    cell_line = names(per_sample_cor),
    new_correlation = as.numeric(per_sample_cor)
  )
  per_sample_mse <- tibble(
    cell_line = names(per_sample_mse),
    new_mean_sq_error = as.numeric(per_sample_mse)
  )

  # Combine the two tibbles
  combined_data <- per_quartile_cor %>%
    left_join(per_quartile_mse, by = c("cell_line", "Transcript length")) %>%
    rename( "mean square error" = mean_sq_error)
  
  # Add "All transcript" row with the new correlations
  all_transcripts <- per_sample_cor %>%
    left_join(per_sample_mse, by = "cell_line") %>%
    mutate(`Transcript length` = "All transcript") %>%
    rename("correlation" = new_correlation,   "mean square error" =  new_mean_sq_error)

  # Combine with the original data
  combined_data <- bind_rows(combined_data, all_transcripts)
  combined_data$sample <- sample_name
  combined_data
}

cor.ont_bulk <- get_ercc_quartiled_states(ont_bulk.tx.dge, sample_name="ONT cDNA" ,tx_len_norm = FALSE)
cor.pb_bulk <- get_ercc_quartiled_states(pb_bulk.tx.dge, sample_name = "PacBio", tx_len_norm = FALSE)
cor.ONT_dRNA <- get_ercc_quartiled_states(drna_bulk.tx.dge, sample_name = "ONT dRNA", tx_len_norm = FALSE)
cor.ill_bulk <- get_ercc_quartiled_states(ill_bulk.tx.dge, sample_name = "Illumina", tx_len_norm = TRUE)

plot_df <- rbind(cor.ont_bulk, cor.pb_bulk, cor.ONT_dRNA, cor.ill_bulk)

# get_stats_comparison
## start a one column tibble called total counts
dge_list <- list(
  'ONT cDNA' = ont_bulk.tx.dge,
  PacBio = pb_bulk.tx.dge,
  "ONT dRNA" = drna_bulk.tx.dge,
  Illumina = ill_bulk.tx.dge
) %>%  lapply(function(x) {
  x[is.sirv_or_ercc(x) & !is.sirv_all(x), ]
})
  
total_counts <- tibble(
  sample = lapply(names(dge_list), function(x) {rep(x, nrow(dge_list[[x]]$samples))}) %>% unlist,
  cell_line = lapply(dge_list, function(x) {x$samples$sample}) %>% unlist,
  total_counts = lapply(dge_list, function(x) {x$counts %>% colSums()}) %>% unlist,
  Transcript_discovery = lapply(dge_list, function(x) {
     x$counts %>% apply(2, function(x) {
       mean(x > 0)
     })
  }) %>% unlist
)


plot_df <- plot_df %>% left_join(total_counts, by = c("cell_line", "sample"))

# working
plot_df$cell_line_sample <- paste(plot_df$sample, plot_df$cell_line, sep = " - ")
# order the cell line sample level first by the sample then by the cell line
plot_df$cell_line_sample <- factor(plot_df$cell_line_sample, levels = plot_df$cell_line_sample %>% unique() %>% sort())
```

```{r Plot: Combine quantiled boxplot (ERCC), fig.height=2, fig.width=7 }
ggplot(plot_df, aes(x = sample, y = `mean square error`, colour = sample)) +
  geom_boxplot() +
  facet_wrap(~ `Transcript length`, ncol=5) +
  theme_minimal() +
  scale_color_manual(values = color_palette) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Samples", y = "mean square error")
```


## SIRV
```{r SIRV scatter, fig.width=15, fig.height=3}
get_sirv_scatter_plot <- function(dge, figure_name, tx_len_norm = TRUE, filter_func = function(x) {is.sirv_E0(dge) | is.long_sirv(dge)}) {

    dge.sirv <- dge[filter_func(dge),]

    # Normalisation functions
    get_ltpm <- function(counts,len) {
        x <- counts/len
        get_lcpm(x)
    }

    get_lcpm <- function(x) { 
        return(log2(x*1e6/sum(x) + 1))
    }

    # Prepare sirv_e0 ground truth
    sirv.gt <- tibble(
        NAME = dge.sirv %>% row.names(),
        LENGTH = dge.sirv$genes$Length,
        GT = rep(1, nrow(dge.sirv$gene)),
        is.long.sirv = is.long_sirv(dge.sirv)
    )
    sirv.gt.norm <- sirv.gt %>% mutate(GT = get_lcpm(GT)) %>%
                                    mutate(N_transcript_per_gene = SIRV.G.Tx.map$tx_count[match(NAME, SIRV.G.Tx.map$tx_name)])
    
    # Normalise observed data
    if (tx_len_norm) {
        dge.sirv.norm <- dge.sirv$counts %>% as_tibble(rownames="NAME")  %>% mutate(across(where(is.numeric), ~ get_ltpm(.x, dge.sirv$genes$EffectiveLength)))
    } else {
        dge.sirv.norm <- dge.sirv$counts %>% as_tibble(rownames="NAME")  %>% mutate(across(where(is.numeric), get_lcpm))
    }
    dge.sirv.norm  <- dge.sirv.norm %>% left_join(dge.sirv$gene %>% as_tibble(rownames="NAME") %>% select(NAME))


    # Merge the ground truth and observed data
    plot_df <- dge.sirv.norm %>% left_join(sirv.gt.norm) %>% pivot_longer(cols=dge.sirv %>% colnames(), names_to = "Sample", values_to = "Observed log-CPM")

    per_sample_sd <- sapply(dge$samples$sample, function(x) {
      sd(plot_df[plot_df$Sample == x,]$`Observed log-CPM`) %>% unlist
    })
    
    per_sample_mad <- sapply(dge$samples$sample, function(x) {
      mad(plot_df[plot_df$Sample == x,]$`Observed log-CPM`) %>% unlist
    })
    
    # Calculate the standard deviation
    plot_df$Sample <- factor(plot_df$Sample)
    SD <- sd(plot_df$`Observed log-CPM`)
    MAD <- mad(plot_df$`Observed log-CPM`)
    MSE <- mean((plot_df$GT - plot_df$`Observed log-CPM`)^2)
    MAE <- mean(abs(plot_df$GT - plot_df$`Observed log-CPM`))

    # Scatter plot
    plot_df <- plot_df %>% mutate(N_transcript_per_gene = N_transcript_per_gene %>% as.factor(), `Transcript length` = LENGTH, `is long sirv` = is.long.sirv)

    p2 <- ggplot(plot_df[rownames(plot_df) %>% sample(nrow(plot_df), replace = F),], aes(y =`Transcript length`, x = `Observed log-CPM`, color = `is long sirv`)) +
      geom_point() +
      geom_vline(xintercept = plot_df$GT[1], linetype = "dashed", color = "red") + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      theme_classic() + 
      labs(title = figure_name, y = "Transcript length", x = "Observed log2(TPM+1)") +
      annotate("text", x = 0, y = 12000, 
               label = paste("SD: ", round(SD, 2), "\nMAD: ", round(MAD, 2), 
                          "\nMSE: ", round(MSE, 2), "\nMAE: ", round(MAE, 2)),
               hjust = 0, vjust = 1, 
               color = "black", size = 4, 
               fontface = "italic") +
      scale_color_viridis_d() +
      xlim(0,20)
    p2 <- ggMarginal(p2, type = "density", margins = "x", fill = NA,  size=2, groupColour = TRUE, groupFill = TRUE)
    
    t <- tibble(
      sample = dge$samples$sample,
      sample_sd = per_sample_sd,
      sample_mad = per_sample_mad,
      merged_sd = SD,
      merged_mad = MAD
    )
    return(list(plot2 = p2, table = t))
}

cor.ont_bulk <- get_sirv_scatter_plot(ont_bulk.tx.dge, figure_name = "ONT cDNA", tx_len_norm = FALSE)
cor.pb_bulk <- get_sirv_scatter_plot(pb_bulk.tx.dge, figure_name = "PacBio", tx_len_norm = FALSE)
cor.ill_bulk <- get_sirv_scatter_plot(ill_bulk.tx.dge, figure_name = "Illumina", tx_len_norm = TRUE)
cor.ONT_dRNA <- get_sirv_scatter_plot(drna_bulk.tx.dge, figure_name = "ONT dRNA", tx_len_norm = FALSE)


plot_df <- cor.ont_bulk$table %>% dplyr::rename(`ONT Bulk`=sample_sd) %>% 
            left_join(cor.ill_bulk$table %>% dplyr::rename(`Illumina Bulk`=sample_sd), by = 'sample') %>% 
            left_join(cor.pb_bulk$table %>% dplyr::rename(`PacBio Bulk`=sample_sd), by = 'sample') %>% 
            left_join(cor.ONT_dRNA$table %>% dplyr::rename(`ONT dRNA`=sample_sd), by = 'sample') %>%
            select(`ONT Bulk`, `PacBio Bulk`, `Illumina Bulk`, `ONT dRNA`) %>% 
            pivot_longer(col=c(`ONT Bulk`, `PacBio Bulk`, `Illumina Bulk`, `ONT dRNA`), values_to = "Standard Deviation", names_to = "Sample")

bx_plot1 <- ggplot(plot_df, aes(x = Sample, y = `Standard Deviation`, fill = Sample)) +
  geom_boxplot(position = position_dodge(width = 0.75)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_minimal() + 
  labs(title = "Per sample SD")

plot_df <- cor.ont_bulk$table %>% dplyr::rename(`ONT Bulk`=sample_mad) %>% 
            left_join(cor.ill_bulk$table %>% dplyr::rename(`Illumina Bulk`=sample_mad), by = 'sample') %>% 
            left_join(cor.pb_bulk$table %>% dplyr::rename(`PacBio Bulk`=sample_mad), by = 'sample') %>% 
            left_join(cor.ONT_dRNA$table %>% dplyr::rename(`ONT dRNA`=sample_mad), by = 'sample') %>%
            select(`ONT Bulk`, `PacBio Bulk`, `Illumina Bulk`, `ONT dRNA`) %>% 
            pivot_longer(col=c(`ONT Bulk`, `PacBio Bulk`, `Illumina Bulk`, `ONT dRNA`), values_to = "Median Absolute Deviation", names_to = "Sample")

bx_plot2 <- ggplot(plot_df, aes(x = Sample, y = `Median Absolute Deviation`, fill = Sample)) +
  geom_boxplot(position = position_dodge(width = 0.75)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_minimal() + 
  labs(title = "Per sample MAD")

list(
  cor.ill_bulk$plot2,
  cor.ont_bulk$plot2,
  cor.ONT_dRNA$plot2,
  cor.pb_bulk$plot2
) %>% patchwork::wrap_plots(ncol = 4, guides = "collect")

```


```{r SIRV quartile state, fig.height=8, fig.width=10}
get_sirv_quartiled_states <- function(dge, sample_name, tx_len_norm = TRUE) {
# 
#   dge <- ont_bulk.tx.dge
#   sample_name="ONT cDNA" 
#   tx_len_norm = FALSE
  dge.sirv <- dge[is.sirv_all(dge), ]

  # Normalisation functions
  get_ltpm <- function(counts, len) {
    x <- counts / len
    get_lcpm(x)
  }

  get_lcpm <- function(x) {
    return(log2(x * 1e6 / sum(x) + 1))
  }

  # Prepare sirv_e0 ground truth
  sirv.gt <- tibble(
      NAME = dge.sirv %>% row.names(),
      LENGTH = dge.sirv$gene$Length,
      GT = rep(1, nrow(dge.sirv$gene)),
      is.long.sirv = is.long_sirv(dge.sirv)
  )
  sirv.gt.norm <- sirv.gt %>% mutate(GT = get_lcpm(GT)) %>%
                                  mutate(N_transcript_per_gene = SIRV.G.Tx.map$tx_count[match(NAME, SIRV.G.Tx.map$tx_name)])
  

  # Normalise observed data
  if (tx_len_norm) {
    dge.sirv.norm <- dge.sirv$counts %>%
      as_tibble(rownames = "NAME") %>%
      mutate(across(where(is.numeric), ~ get_ltpm(.x, dge.sirv$genes$EffectiveLength)))
  } else {
    dge.sirv.norm <- dge.sirv$counts %>%
      as_tibble(rownames = "NAME") %>%
      mutate(across(where(is.numeric), get_lcpm))
  }
  dge.sirv.norm <- dge.sirv.norm %>% left_join(dge.sirv$gene %>% as_tibble(rownames = "NAME") %>% select(NAME))

  # Merge the ground truth and observed data
  df <- dge.sirv.norm %>% left_join(sirv.gt.norm)

  combined_df <- df %>% pivot_longer(cols = dge.sirv$samples$sample, names_to = "Sample", values_to = "Observed log-CPM")

  # get the per sample correlation, standard deviation and mean absolute deviation
  per_sample_sd <- sapply(dge$samples$sample, function(x) {
    sd(combined_df[combined_df$Sample == x,]$`Observed log-CPM`) %>% unlist
  })
  
  per_sample_mad <- sapply(dge$samples$sample, function(x) {
    mad(combined_df[combined_df$Sample == x,]$`Observed log-CPM`) %>% unlist
  })
    
  per_sample_mse <- sapply(dge$samples$sample, function(x) {
      mean((combined_df[combined_df$Sample == x, ]$GT - combined_df[combined_df$Sample == x, ]$`Observed log-CPM`)^2) %>% unlist()
  })
    
  per_sample_mae <- sapply(dge$samples$sample, function(x) {
      mean(abs(combined_df[combined_df$Sample == x, ]$GT - combined_df[combined_df$Sample == x, ]$`Observed log-CPM`)) %>% unlist()
  })

  # Calculate the standard deviation
  combined_df$Sample <- factor(combined_df$Sample)
  # SD <- sd(combined_df$`Observed log-CPM`)
  # MAD <- mad(combined_df$`Observed log-CPM`)
  # MSE <- mean((combined_df$GT - combined_df$`Observed log-CPM`)^2)
  # MAE <- mean(abs(combined_df$GT - combined_df$`Observed log-CPM`))


  combined_df <- combined_df %>% rename("Transcript length" = LENGTH)

  # color by the quantile of the transcript length
  combined_df$`Transcript length` <- cut(combined_df$`Transcript length`,
    breaks = quantile(combined_df$`Transcript length`,
      probs = seq(0, 1, 0.25)
    ),
    include.lowest = TRUE,
    labels = c("1st Quartile", "2nd Quartile", "3rd Quartile", "4th Quartile")
  )

  # calculate the correlation per quartile and per sample, and also give the correlation overall all four quartiles
  per_quartile_mse <- combined_df %>%
    group_by(Sample, `Transcript length`) %>%
    summarise(mean_sq_error = mean((GT - `Observed log-CPM`)^2)) %>%
    rename(
      "cell_line" = Sample
    ) %>%
    ungroup()
  
  per_quartile_mae <- combined_df %>%
    group_by(Sample, `Transcript length`) %>%
    summarise(mean_abs_error = mean(abs(GT - `Observed log-CPM`))) %>%
    rename(
      "cell_line" = Sample
    ) %>%
    ungroup()

  # merge the overall correlation with the per quartile correlation
  per_sample_mse <- tibble(
    cell_line = names(per_sample_mse),
    new_mean_sq_error = as.numeric(per_sample_mse)
  )

  per_sample_mae <- tibble(
    cell_line = names(per_sample_mae),
    new_mean_abs_error = as.numeric(per_sample_mae)
  )

  # Combine the two tibbles
  combined_data <- per_quartile_mae %>%
    left_join(per_quartile_mse, by = c("cell_line", "Transcript length")) %>%
    rename("mean square error"=mean_sq_error, "mean absolute error"=mean_abs_error)
  
  # Add "All transcript" row with the new correlations
  all_transcripts <- per_sample_mae %>%
    left_join(per_sample_mse, by = "cell_line") %>%
    mutate(`Transcript length` = "All transcript") %>%
    rename("mean absolute error"=new_mean_abs_error, "mean square error"=new_mean_sq_error)

  # Combine with the original data
  combined_data <- bind_rows(combined_data, all_transcripts)
  combined_data$sample <- sample_name
  combined_data
}

cor.ont_bulk <- get_sirv_quartiled_states(ont_bulk.tx.dge, sample_name="ONT cDNA" ,tx_len_norm = FALSE)
cor.pb_bulk <- get_sirv_quartiled_states(pb_bulk.tx.dge, sample_name = "PacBio", tx_len_norm = FALSE)
cor.ONT_dRNA <- get_sirv_quartiled_states(drna_bulk.tx.dge, sample_name = "ONT dRNA", tx_len_norm = FALSE)
cor.ill_bulk <- get_sirv_quartiled_states(ill_bulk.tx.dge, sample_name = "Illumina", tx_len_norm = TRUE)

plot_df <- rbind(cor.ont_bulk, cor.pb_bulk, cor.ONT_dRNA, cor.ill_bulk)

# get_stats_comparison
## start a one column tibble called total counts
dge_list <- list(
  'ONT cDNA' = ont_bulk.tx.dge,
  PacBio = pb_bulk.tx.dge,
  "ONT dRNA" = drna_bulk.tx.dge,
  Illumina = ill_bulk.tx.dge
) %>%  lapply(function(x) {
  x[is.sirv_or_ercc(x) & !is.sirv_all(x), ]
})
  
total_counts <- tibble(
  sample = lapply(names(dge_list), function(x) {rep(x, nrow(dge_list[[x]]$samples))}) %>% unlist,
  cell_line = lapply(dge_list, function(x) {x$samples$sample}) %>% unlist,
  total_counts = lapply(dge_list, function(x) {x$counts %>% colSums()}) %>% unlist,
  Transcript_discovery = lapply(dge_list, function(x) {
     x$counts %>% apply(2, function(x) {
       mean(x > 0)
     })
  }) %>% unlist
)


plot_df <- plot_df %>% left_join(total_counts, by = c("cell_line", "sample"))


# working
plot_df$cell_line_sample <- paste(plot_df$sample, plot_df$cell_line, sep = " - ")
# order the cell line sample level first by the sample then by the cell line
plot_df$cell_line_sample <- factor(plot_df$cell_line_sample, levels = plot_df$cell_line_sample %>% unique() %>% sort())
```
```{r Plot: Combine quantiled boxplot (SIRV), fig.height=2, fig.width=7 }

ggplot(plot_df, aes(x = sample, y = `mean absolute error`, colour = sample)) +
  geom_boxplot() +
  facet_wrap(~ `Transcript length`,  ncol=5) +
  theme_minimal() +
  scale_color_manual(values = color_palette) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(x = "Samples", y = "mean square error")
```
# PLOT: Human transcript total counts (stratified by transcript length)
```{r Huamn transcript discovery rate, fig.width=6, fig.height=4}
dge_list <-   list(ont_bulk.tx.dge[is.human(ont_bulk.tx.dge),], 
      drna_bulk.tx.dge[is.human(drna_bulk.tx.dge),],
       ill_bulk.tx.dge[is.human(ill_bulk.tx.dge),], 
       pb_bulk.tx.dge[is.human(pb_bulk.tx.dge),])

dataset_list <- list("ONT BULK", "ONT dRNA", "Illumina BULK", "PacBio BULK")
figure_name <- "Human transcript discovery rate"

  plot_df <- tibble()
  for (i in 1:length(dge_list)) {
    dge <- dge_list[[i]]
    dataset <- dataset_list[[i]]

    tx_discov_df <- tibble(
      `Total count` = dge$counts %>% rowSums(),
      `TPM` = dge %>% get_tpm %>% rowMeans()
    )

    tx_discov_df <- tx_discov_df %>% mutate( `transcript length` = dge$gene$Length) 
    # bin the transcript length every 500 and make everything above 10000 to be in the same bin
    tx_discov_df$`transcript length` <- cut(
                                          tx_discov_df$`transcript length`,
                                          breaks = c(seq(0, 4000, 200), Inf),
                                          labels = c(paste0(seq(0, 3.8, 0.2),"k-", seq(0.2, 4, 0.2),"k"), "4k+"),
                                          include.lowest = TRUE)
    # group by the transcript length and calculate the mean of the transcript discovered
    tx_discov_df <- tx_discov_df %>%
      group_by(`transcript length`) %>%
      summarise(`Total count` = sum(`Total count`),
                TPM = sum(TPM)) %>%
      ungroup()
    tx_discov_df$Dataset <- dataset
    plot_df <- rbind(plot_df, tx_discov_df)
  }
  
  
  p <- ggplot(plot_df, aes(`transcript length`, y = TPM, color = Dataset, group = Dataset)) +
    geom_line(position = position_dodge(width = 0.2), linewidth = 1) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
    scale_color_manual(values = color_palette[c("Illumina", "ONT cDNA", "ONT dRNA", "PacBio")] %>% unname()) +
    labs(title = "Human transcript quantification", x = "Transcript Length", y = "TPM")
p
```


# Differential gene expression

## Preprocessing
1. Filter out lowly expressed genes and transcript using `filterByExpr` for each dataset, using default parameters 
  - The filtering will be done on single dataset level, and the union of the filtered genes will be used for the downstream analysis
  - Note: The starting number of gene/transcript is smaller for the salmon pseudoalignment method compared to the kallisto and oarfish methods. This is due to the fact that the genecode transcript FASTA has more transcript/gene than their annotation GTF file. Given the proportion is tiny (<0.2% transcripts), to keep the analysis consistent, we will remove the genes (either expressed or not) that are not present in salmon output from the kallisto and oarfish datasets.
2. Normalise the gene counts using `calcNormFactors` with `TMM` methods for each dataset 
3. Convert the counts data to TPM
  For the typical DE analysis workflow, edgeR and limma do not specifically require TPM values i.e. adjusting for transcript length is not necessary. Because the feature-specific scaling factor is constant across all samples, the length of the transcript does not affect the differential analysis. However, for the purpose of comparing the short reads and long reads, we will convert the counts to TPM values. 
    - For Short reads, the TPM is calculated using the formula: `TPM = (count/length) * 1e6 / sum(count/length)`
    - For Long reads, the TPM is calculated using the formula (equivalent to CPM): `TPM = (count / sum(count)) * 1e6`

### Filter genes
```{r gene filtering for DE}
#GENE 
## 1. get common genes
common_genes <- Reduce(intersect, lapply(list(ill_bulk.gene.dge, ont_bulk.gene.dge, pb_bulk.gene.dge, drna_bulk.gene.dge), rownames))

ill_bulk.gene.dge <- ill_bulk.gene.dge[common_genes, ]
ont_bulk.gene.dge <- ont_bulk.gene.dge[common_genes, ]
pb_bulk.gene.dge <- pb_bulk.gene.dge[common_genes, ]
drna_bulk.gene.dge <- drna_bulk.gene.dge[common_genes, ]

## 2. filter by expression
keep <- filterByExpr(ill_bulk.gene.dge, group = ill_bulk.gene.dge$samples$sample) &
          filterByExpr(ont_bulk.gene.dge, group = ont_bulk.gene.dge$samples$sample) &
          filterByExpr(pb_bulk.gene.dge, group = pb_bulk.gene.dge$samples$sample) &
          filterByExpr(drna_bulk.gene.dge, group = drna_bulk.gene.dge$samples$sample)

table(keep)

ill_bulk.gene.dge <- ill_bulk.gene.dge[keep, ]
ont_bulk.gene.dge <- ont_bulk.gene.dge[keep, ]
pb_bulk.gene.dge <- pb_bulk.gene.dge[keep, ]
drna_bulk.gene.dge <- drna_bulk.gene.dge[keep, ]

```

### 5. Merge DGElist
```{r Merge DGEs}
# Gene
ill_bulk.gene.dge$samples$platform <- "Illumina"
ont_bulk.gene.dge$samples$platform <- "ONT cDNA"
pb_bulk.gene.dge$samples$platform <- "PacBio"
drna_bulk.gene.dge$samples$platform <- "ONT dRNA"
bulk.gene.dge.merge <- cbind(
  ill_bulk.gene.dge,
  ont_bulk.gene.dge,
  pb_bulk.gene.dge,
  drna_bulk.gene.dge
)

# Transcript
ill_bulk.tx.dge$samples$platform <- "Illumina"
ont_bulk.tx.dge$samples$platform <- "ONT cDNA"

pb_bulk.tx.dge$samples$platform <- "PacBio"
drna_bulk.tx.dge$samples$platform <- "ONT dRNA"

bulk.tx.dge.merge <- cbind(
  ill_bulk.tx.dge,
  ont_bulk.tx.dge,
  pb_bulk.tx.dge,
  drna_bulk.tx.dge
)
```

## MDS (Merged) Human transcript
```{r}
# Normalisation
## get_log_TPM Gene: TPM for illumina and CPM for long-read
ill <- bulk.gene.dge.merge[is.human(bulk.gene.dge.merge), bulk.gene.dge.merge$samples$platform == "Illumina"]
ill.rpkm <- rpkm(ill, gene.length='Length',normalized.lib.sizes = F)
tpm.ill <- t( t(ill.rpkm) / colSums(ill.rpkm) ) * 1e6
lr <-  bulk.gene.dge.merge[is.human(bulk.gene.dge.merge), bulk.gene.dge.merge$samples$platform != "Illumina"]
tpm.lr <- t( t(lr$counts) / colSums(lr$counts) ) * 1e6

log.tpm.gene <- log2(cbind(tpm.ill, tpm.lr) + 1)
sample.gene = rbind(ill$samples, lr$samples)

## get_log_TPM Tx: TPM for illumina andCPM for long-read
ill <- bulk.tx.dge.merge[is.human(bulk.tx.dge.merge), bulk.tx.dge.merge$samples$platform == "Illumina"]
ill.rpkm <- rpkm(ill, gene.length='EffectiveLength', normalized.lib.sizes = F)
tpm.ill <- t( t(ill.rpkm) / colSums(ill.rpkm) ) * 1e6
lr <-  bulk.tx.dge.merge[is.human(bulk.tx.dge.merge), bulk.tx.dge.merge$samples$platform != "Illumina"]
tpm.lr <- t( t(lr$counts) / colSums(lr$counts) ) * 1e6

log.tpm.tx <- log2(cbind(tpm.ill, tpm.lr) + 1)
sample.tx = rbind(ill$samples, lr$samples)

log.tpm.gene.dge <- DGEList(log.tpm.gene, samples=sample.gene)
log.tpm.tx.dge <- DGEList(log.tpm.tx, samples=sample.tx)

```
### Gene count MDS
```{r, fig.height=3, fig.width=8}
# Set up MDS plot function
myMDS <- function(dge, mds) {
  # normalisation
  mds_data <- data.frame(
    Dim1 = mds$x,
    Dim2 = mds$y,
    cell.line = dge$sample$sample,
    Cancer.type = dge$sample$group,
    Data.type = dge$sample$platform,
    Sequins.mix = dge$samples$sequins
  )

  p <- ggplot(mds_data, aes(x = Dim1, y = Dim2, color = Cancer.type, shape = Data.type)) +
    geom_point(size = 3, alpha = 0.6) + # Plot points
    #geom_text_repel(size = 3) +
    labs(title = "MDS plot", 
        x = paste0("Dimension 1 (", round(mds$var.explained[1]*100, 2), "%)" ) , 
        y = paste0("Dimension 2 (", round(mds$var.explained[2]*100, 2), "%)" )) +
    scale_color_viridis_d() + # Set color scale
    theme_minimal() 
  return(p)
}

mds.gene <- plotMDS(log.tpm.gene.dge, plot = FALSE)
p1 <- myMDS(log.tpm.gene.dge, mds.gene) + ggtitle("Human gene counts")
p2 <- myMDS(log.tpm.gene.dge, mds.gene) + ggtitle("Human gene counts")  + 
            aes(color = Data.type, shape = Cancer.type) + 
            scale_color_manual(values = color_palette[c("Illumina", "ONT cDNA", "ONT dRNA", "PacBio")] %>% unname())
p1 | p2 



```




### Transcript count

```{r, fig.height=3, fig.width=8}
mds.tx <- plotMDS(log.tpm.tx.dge, plot = FALSE)
p1 <- myMDS(log.tpm.tx.dge, mds.tx) + ggtitle("Human tx counts")
p2 <- myMDS(log.tpm.tx.dge, mds.tx) + ggtitle("Human tx counts")  + 
            aes(color = Data.type, shape = Cancer.type) + 
            scale_color_manual(values = color_palette[c("Illumina", "ONT cDNA", "ONT dRNA", "PacBio")] %>% unname())
p1 | p2 
```
## PVCA (logTPM) human

```{r, fig.height=3, fig.width=4}
library(pvca)
library(Biobase)


# PVCA
# Run PVCA
colnames(log.tpm.gene) <- NULL
expr_set <- ExpressionSet(
  assayData = as.matrix(log.tpm.gene),
  phenoData = AnnotatedDataFrame(sample.gene)
)
pvca_result <- pvcaBatchAssess(
  expr_set,
  batch.factors = c("platform", "group"),  # Specify the metadata columns to test
  threshold = 0.1
)

# Transcript
colnames(log.tpm.tx) <- NULL
expr_set <- ExpressionSet(
  assayData = as.matrix(log.tpm.tx),
  phenoData = AnnotatedDataFrame(sample.tx)
)
pvca_result2 <- pvcaBatchAssess(
  expr_set,
  batch.factors = c("platform", "group"),  # Specify the metadata columns to test
  threshold = 0.1
)

# Create a data frame from the pvca_result list
plot_df <- as.data.frame(pvca_result$dat %>% t )
rownames(plot_df) <- pvca_result$label
plot_df <- plot_df %>% rownames_to_column("Variable") %>% rename("Value" = V1) %>% mutate(type="Gene-level")

# Create a data frame from the pvca_result list
plot_df2 <- as.data.frame(pvca_result2$dat %>% t )
rownames(plot_df2) <- pvca_result2$label
plot_df2$type <- "Transcript quantification"
plot_df2 <- plot_df2 %>% rownames_to_column("Variable") %>% rename("Value" = V1) %>% mutate(type="Transcript-level")

plot_df <- plot_df %>% bind_rows(plot_df2)

# Create a bar plot using ggplot
ggplot(plot_df, aes(x=type, y = Value, fill = Variable)) +
  geom_bar(stat = "identity", position = "fill") +
  labs( x = "Variable", y = "Value") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


## MDS (Merged) SIRV transcript
```{r}
# Normalisation
## get_log_TPM Gene: TPM for illumina and CPM for long-read
ill <- bulk.gene.dge.merge[is.sirv_all(bulk.gene.dge.merge), bulk.gene.dge.merge$samples$platform == "Illumina"]
ill.rpkm <- rpkm(ill, gene.length='Length',normalized.lib.sizes = F)
tpm.ill <- t( t(ill.rpkm) / colSums(ill.rpkm) ) * 1e6
lr <-  bulk.gene.dge.merge[is.sirv_all(bulk.gene.dge.merge), bulk.gene.dge.merge$samples$platform != "Illumina"]
tpm.lr <- t( t(lr$counts) / colSums(lr$counts) ) * 1e6

log.tpm.gene <- log2(cbind(tpm.ill, tpm.lr) + 1)
sample.gene = rbind(ill$samples, lr$samples)

## get_log_TPM Tx: TPM for illumina and CPM for long-read
ill <- bulk.tx.dge.merge[is.sirv_all(bulk.tx.dge.merge), bulk.tx.dge.merge$samples$platform == "Illumina"]
ill.rpkm <- rpkm(ill, is.sirv_all='EffectiveLength', normalized.lib.sizes = F)
tpm.ill <- t( t(ill.rpkm) / colSums(ill.rpkm) ) * 1e6
lr <-  bulk.tx.dge.merge[is.sirv_all(bulk.tx.dge.merge), bulk.tx.dge.merge$samples$platform != "Illumina"]
tpm.lr <- t( t(lr$counts) / colSums(lr$counts) ) * 1e6

log.tpm.tx <- log2(cbind(tpm.ill, tpm.lr) + 1)
sample.tx = rbind(ill$samples, lr$samples)

log.tpm.gene.dge <- DGEList(log.tpm.gene, samples=sample.gene)
log.tpm.tx.dge <- DGEList(log.tpm.tx, samples=sample.tx)

```
### Gene count MDS
```{r, fig.height=3, fig.width=8}
# Set up MDS plot function
myMDS <- function(dge, mds) {
  # normalisation
  mds_data <- data.frame(
    Dim1 = mds$x,
    Dim2 = mds$y,
    cell.line = dge$sample$sample,
    Cancer.type = dge$sample$group,
    Data.type = dge$sample$platform,
    Sequins.mix = dge$samples$sequins
  )

  p <- ggplot(mds_data, aes(x = Dim1, y = Dim2, color = Cancer.type, shape = Data.type)) +
    geom_point(size = 3, alpha = 0.6) + # Plot points
    #geom_text_repel(size = 3) +
    labs(title = "MDS plot", 
        x = paste0("Dimension 1 (", round(mds$var.explained[1]*100, 2), "%)" ) , 
        y = paste0("Dimension 2 (", round(mds$var.explained[2]*100, 2), "%)" )) +
    scale_color_viridis_d() + # Set color scale
    theme_minimal() 
  return(p)
}

mds.gene <- plotMDS(log.tpm.gene.dge, plot = FALSE)
p1 <- myMDS(log.tpm.gene.dge, mds.gene) + ggtitle("Human gene counts")
p2 <- myMDS(log.tpm.gene.dge, mds.gene) + ggtitle("Human gene counts")  + 
            aes(color = Data.type, shape = Cancer.type) + 
            scale_color_manual(values = color_palette[c("Illumina", "ONT cDNA", "ONT dRNA", "PacBio")] %>% unname())
p1 | p2 



```

### Transcript count

```{r, fig.height=3, fig.width=8}
mds.tx <- plotMDS(log.tpm.tx.dge, plot = FALSE)
p1 <- myMDS(log.tpm.tx.dge, mds.tx) + ggtitle("Human tx counts")
p2 <- myMDS(log.tpm.tx.dge, mds.tx) + ggtitle("Human tx counts")  + 
            aes(color = Data.type, shape = Cancer.type) + 
            scale_color_manual(values = color_palette[c("Illumina", "ONT cDNA", "ONT dRNA", "PacBio")] %>% unname())
p1 | p2 
```


## MDS (Merged) Sequins transcript
```{r}
# Normalisation
## get_log_TPM Gene: TPM for illumina and CPM for long-read
ill <- bulk.gene.dge.merge[is.sequins(bulk.gene.dge.merge), bulk.gene.dge.merge$samples$platform == "Illumina"]
ill.rpkm <- rpkm(ill, gene.length='Length',normalized.lib.sizes = F)
tpm.ill <- t( t(ill.rpkm) / colSums(ill.rpkm) ) * 1e6
lr <-  bulk.gene.dge.merge[is.sequins(bulk.gene.dge.merge), bulk.gene.dge.merge$samples$platform != "Illumina"]
tpm.lr <- t( t(lr$counts) / colSums(lr$counts) ) * 1e6

log.tpm.gene <- log2(cbind(tpm.ill, tpm.lr) + 1)
sample.gene = rbind(ill$samples, lr$samples)

## get_log_TPM Tx: TPM for illumina and CPM for long-read
ill <- bulk.tx.dge.merge[is.sequins(bulk.tx.dge.merge), bulk.tx.dge.merge$samples$platform == "Illumina"]
ill.rpkm <- rpkm(ill, is.sequins='EffectiveLength', normalized.lib.sizes = F)
tpm.ill <- t( t(ill.rpkm) / colSums(ill.rpkm) ) * 1e6
lr <-  bulk.tx.dge.merge[is.sequins(bulk.tx.dge.merge), bulk.tx.dge.merge$samples$platform != "Illumina"]
tpm.lr <- t( t(lr$counts) / colSums(lr$counts) ) * 1e6

log.tpm.tx <- log2(cbind(tpm.ill, tpm.lr) + 1)
sample.tx = rbind(ill$samples, lr$samples)

log.tpm.gene.dge <- DGEList(log.tpm.gene, samples=sample.gene)
log.tpm.tx.dge <- DGEList(log.tpm.tx, samples=sample.tx)

```
### Gene count MDS
```{r, fig.height=3, fig.width=8}
# Set up MDS plot function
myMDS <- function(dge, mds) {
  # normalisation
  mds_data <- data.frame(
    Dim1 = mds$x,
    Dim2 = mds$y,
    cell.line = dge$sample$sample,
    Cancer.type = dge$sample$group,
    Data.type = dge$sample$platform,
    Sequins.mix = dge$samples$sequins
  )

  p <- ggplot(mds_data, aes(x = Dim1, y = Dim2, color = Cancer.type, shape = Data.type)) +
    geom_point(size = 3, alpha = 0.6) + # Plot points
    #geom_text_repel(size = 3) +
    labs(title = "MDS plot", 
        x = paste0("Dimension 1 (", round(mds$var.explained[1]*100, 2), "%)" ) , 
        y = paste0("Dimension 2 (", round(mds$var.explained[2]*100, 2), "%)" )) +
    scale_color_viridis_d() + # Set color scale
    theme_minimal() 
  return(p)
}

mds.gene <- plotMDS(log.tpm.gene.dge, plot = FALSE)
p1 <- myMDS(log.tpm.gene.dge, mds.gene) + ggtitle("Human gene counts")
p2 <- myMDS(log.tpm.gene.dge, mds.gene) + ggtitle("Human gene counts")  + 
            aes(color = Data.type, shape = Cancer.type) + 
            scale_color_manual(values = color_palette[c("Illumina", "ONT cDNA", "ONT dRNA", "PacBio")] %>% unname())
p1 | p2 



```

### Transcript count

```{r, fig.height=3, fig.width=8}
mds.tx <- plotMDS(log.tpm.tx.dge, plot = FALSE)
p1 <- myMDS(log.tpm.tx.dge, mds.tx) + ggtitle("Human tx counts")
p2 <- myMDS(log.tpm.tx.dge, mds.tx) + ggtitle("Human tx counts")  + 
            aes(color = Data.type, shape = Cancer.type) + 
            scale_color_manual(values = color_palette[c("Illumina", "ONT cDNA", "ONT dRNA", "PacBio")] %>% unname())
p1 | p2 
```



# Correlation (Sup figure)

```{r Heatmap Gene, fig.width=12, fig.height=5, eval=T}
library(ComplexHeatmap)
library(circlize)

# Sample annotation
sample_anno <- log.tpm.gene.dge$samples %>%
  select(group, platform, sample) %>%
  mutate(across(everything(), as.factor)) %>%
  droplevels()

# Correlation matrix
cor_mat <- cor(log.tpm.gene.dge$counts, method = "pearson")
# Get sample names
sample_ids <- unique(sample_anno$sample)

# Color function
col_fun <- colorRamp2(c(0.5, 0.75, 1), c("#2166AC", "white", "#B2182B"))

# Store heatmaps per sample
ht_list <- lapply(sample_ids, function(sid) {
  cols <- which(sample_anno$sample == sid)
  mat <- cor_mat[cols, cols]
  rownames(mat) <- sample_anno[sample_anno$sample == sid,]$platform
  colnames(mat) <- sample_anno[sample_anno$sample == sid,]$platform
  
  Heatmap(mat,
          name = as.character(sid),
          show_row_names = T,
          show_column_names = T,
          col = col_fun,
          cluster_rows = T,
          cluster_columns = T,
            row_dend_width = unit(4, "mm"),       # Adjust row dendrogram width
          column_dend_height = unit(4, "mm"))
})


# Create grobs from heatmaps
ht_grobs <- lapply(ht_list, function(ht) grid.grabExpr(draw(ht, merge_legend = TRUE)))

# Arrange in 2x4 layout
grid.arrange(grobs = ht_grobs, nrow = 2, ncol = 4,
             top = textGrob("Gene level: Sample-wise correlation heatmaps: log2(TPM+1)", gp = gpar(fontsize = 16, fontface = "bold")))
```
```{r Heatmap tx, fig.width=12, fig.height=5, eval=T}
library(ComplexHeatmap)
library(circlize)

# Sample annotation
sample_anno <- log.tpm.tx.dge$samples %>%
  select(group, platform, sample) %>%
  mutate(across(everything(), as.factor)) %>%
  droplevels()

# Correlation matrix
cor_mat <- cor(log.tpm.tx.dge$counts, method = "pearson")
# Get sample names
sample_ids <- unique(sample_anno$sample)

# Color function
col_fun <- colorRamp2(c(0.5, 0.75, 1), c("#2166AC", "white", "#B2182B"))

# Store heatmaps per sample
ht_list <- lapply(sample_ids, function(sid) {
  cols <- which(sample_anno$sample == sid)
  mat <- cor_mat[cols, cols]
  rownames(mat) <- sample_anno[sample_anno$sample == sid,]$platform
  colnames(mat) <- sample_anno[sample_anno$sample == sid,]$platform
  
  Heatmap(mat,
          name = as.character(sid),
          show_row_names = T,
          show_column_names = T,
          col = col_fun,
          cluster_rows = T,
          cluster_columns = T,
            row_dend_width = unit(4, "mm"),       # Adjust row dendrogram width
          column_dend_height = unit(4, "mm"))
})


# Create grobs from heatmaps
ht_grobs <- lapply(ht_list, function(ht) grid.grabExpr(draw(ht, merge_legend = TRUE)))

# Arrange in 2x4 layout
grid.arrange(grobs = ht_grobs, nrow = 2, ncol = 4,
             top = textGrob("Tx level, Sample-wise correlation heatmaps: log2(TPM+1)", gp = gpar(fontsize = 16, fontface = "bold")))
```

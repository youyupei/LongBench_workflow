---
title: "DTU_analysis (DTUrtle/DRIMseq)"
author: "Ashleigh"
date: "2025-03-31"
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_float: yes
    number_sections: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: '4'
params:
  random_seed: 2024
  cache_dir: NULL
  fig.path: NULL
  ncore: 16
  sirv_ercc_gtf: '/vast/projects/LongBench/reference_files/SIRV_Set4_Norm_Sequences_20210507/SIRV_ERCC_longSIRV_multi-fasta_20210507.gtf'
  sequins_gtf: '/vast/projects/LongBench/reference_files/Sequin_resources/v2.4/rnasequin_annotation_2.4.gtf'
  sequins_tsv: '/vast/projects/LongBench/reference_files/Sequin_resources/v2.4/rnasequin_isoforms_2.4.tsv'
  human_gtf: '/vast/projects/LongBench/reference_files/GRCh38/gencode.v44.annotation.gtf'
  ont_sc_oarfish_dir: '/home/users/allstaff/you.yu/LongBench/analysis/lr_sc_sn/result/PseudoBulkOarfishCov/ont_sc'
  ont_sn_oarfish_dir: '/home/users/allstaff/you.yu/LongBench/analysis/lr_sc_sn/result/PseudoBulkOarfishCov/ont_sn'
  pb_sc_oarfish_dir: '/home/users/allstaff/you.yu/LongBench/analysis/lr_sc_sn/result/PseudoBulkOarfishCov/pb_sc'
  pb_sn_oarfish_dir: '/home/users/allstaff/you.yu/LongBench/analysis/lr_sc_sn/result/PseudoBulkOarfishCov/pb_sn'
  bulk_meta: '/vast/projects/LongBench/sequencing_data/illumina_bulk/metadata.txt'
---

```{r Load libraries, include=FALSE}
#library(DTUrtle)
library(sparseDRIMSeq)
library(dplyr)
library(GenomicFeatures)
library(BiocParallel)
library(Matrix)
library(tximport)
library(ggplot2)
library(patchwork)
library(edgeR)
library(tidyr)
source("/vast/projects/LongBench/analysis/bulk_dturtle_analysis/dtu_Rfunction.R")
if (!is.null(params$ncore)){
  biocpar <- BiocParallel::MulticoreParam(params$ncore)
} else {
  biocpar <- BiocParallel::MulticoreParam(1)
}


# Set cache.path only if params$cache_dir is not NULL
knitr::opts_chunk$set(
  cache = !is.null(params$cache_dir),  # Enable caching only if cache_dir is provided
	fig.height = 5,
	fig.width = 7,                # Set default figure height
  warning = FALSE,                    # Suppress warnings in the output
  fig.path = params$fig.path,         # Set figure path (NULL if not provided)
  dev = if (!is.null(params$fig.path)) c("png", "svg") else NULL  # Set output devices if fig.path is provided
)

# Set cache.path only if params$cache_dir is not NULL
if (!is.null(params$cache_dir)) {
  knitr::opts_chunk$set(cache.path = params$cache_dir)
}


  
```




```{r function for splitting the transcript origin, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
is.sequins <- function(dge) {grepl("^R", rownames(dge))}
is.human <- function(dge) {grepl("^ENS", rownames(dge))}
is.sirv_or_ercc <- function(dge) {!is.human(dge) & !is.sequins(dge)} # this is the whole SIRV set4 (ERCC + SIRV E0 + Long SIRV)
is.sirv_E0 <- function(dge) {grepl("^SIRV\\d{3}$", rownames(dge))} 
is.sirv_all <- function(dge) {grepl("^SIRV", rownames(dge))} # including all SIRV E0 and Long SIRV
is.long_sirv <- function(dge) {grepl("^SIRV\\d{4}", rownames(dge))}
is.ercc <- function(dge) {!is.human(dge) & !is.sequins(dge) & !is.sirv_all(dge)}
```

# Setup 

## Sample metdata
We need a sample metadata data frame, specifying which sample belongs to which comparison group. 
```{r echo=TRUE}
bulk_meta <- read.delim(params$bulk_meta, header = TRUE, sep = ",", stringsAsFactors = FALSE)
bulk_meta <- data.frame("id" = bulk_meta$sample,
                        "group"= bulk_meta$group,
                        "sequins"=bulk_meta$sequins,
                        stringsAsFactors = FALSE)
bulk_meta
```

## Prepare tx2gene (GTF annotation importing and processing)

```{r GTF annotation importing, echo=TRUE}
calcTxNum <- function(G.Tx.map){
  geneid = rep(NA, nrow(G.Tx.map))
  txcount = table(G.Tx.map$gene_id)
  txnum = as.numeric(txcount[match(G.Tx.map$gene_id, names(txcount))])
}
# SIRV
SIRV_tx <- GenomicFeatures::makeTxDbFromGFF(params$sirv_ercc_gtf, format = "gtf") %>% GenomicFeatures::transcripts(columns = c("tx_id", "tx_name", "gene_id"))
SIRV.G.Tx.map <- tibble(
  gene_id = SIRV_tx$gene_id %>% unlist,
  tx_name = SIRV_tx$tx_name,
  seqnames = as.character(seqnames(SIRV_tx))
)
rm(SIRV_tx)
SIRV.G.Tx.map$tx_count <- SIRV.G.Tx.map %>% calcTxNum

# Sequins
sequins_tx  <- GenomicFeatures::makeTxDbFromGFF(params$sequins_gtf, format = "gtf") %>% GenomicFeatures::transcripts(columns = c("tx_id", "tx_name", "gene_id"))
sequins.G.Tx.map <- tibble(
  gene_id = sequins_tx$gene_id %>% unlist,
  tx_name = sequins_tx$tx_name,
  seqnames = as.character(seqnames(sequins_tx))
)
rm(sequins_tx)
sequins.G.Tx.map$tx_count <- sequins.G.Tx.map %>% calcTxNum

# Human
human_tx  <- GenomicFeatures::makeTxDbFromGFF(params$human_gtf, format = "gtf") %>% GenomicFeatures::transcripts(columns = c("tx_id", "tx_name", "gene_id"))
human.G.Tx.map <- tibble(
  gene_id = human_tx$gene_id %>% unlist,
  tx_name = human_tx$tx_name,
  seqnames = as.character(seqnames(human_tx))
)
rm(human_tx)
human.G.Tx.map$tx_count <- human.G.Tx.map %>% calcTxNum

```


```{r GTF annotation processing, echo=TRUE}
# Merge all tx2gene - > need all genes for tximport to run properly but we will do dtu only on the human genes 
sequins_tx2gene <- sequins.G.Tx.map[, c("tx_name", "gene_id", "seqnames")]
SIRV_tx2gene <- SIRV.G.Tx.map[, c("tx_name", "gene_id", "seqnames")]
human_tx2gene <- human.G.Tx.map[, c("tx_name", "gene_id", "seqnames")]
tx2gene <- rbind(human_tx2gene, sequins_tx2gene, SIRV_tx2gene)
tx2gene <- as.data.frame(tx2gene)
head(tx2gene)

```


## Read quantification data (salmon/oarfish)
Here `salmon` used to quantify the short-read sequencing transcript data (PB SN) whilst `oarfish` used to quantify long-read sequencing data (Oxford Nanopore Technologies (ONT) (`ONT_1` (cDNA sequencing), `ONT_2` (dRNA sequencing))
```{r Get quantification files, echo=TRUE}

# Get quant.sf file paths
get_quant_paths <- function(dirs, file_name) {
  # Generate file paths for quantification files
  quant_paths <- file.path(dirs, file_name)
  return(quant_paths)
}

# Define directories with their corresponding expected file names
oarfish_dirs <- list(
  pb_sn = list(dir = params$pb_sn_oarfish_dir, file_name = ".quant"),
  ont_sc = list(dir = params$ont_sc_oarfish_dir, file_name = ".quant"),
  ont_sn = list(dir = params$ont_sn_oarfish_dir, file_name = ".quant"),
  pb_sc = list(dir = params$pb_sc_oarfish_dir, file_name = ".quant")
)

# Apply function to each directory to get all quant file paths
quant_paths <- lapply(oarfish_dirs, function(dir_info) {
  # Get the directory and file name from dir_info
  dir <- dir_info$dir
  file_name <- dir_info$file_name
  
  # List all subdirectories and get the quant file paths
  sub_dirs <- list.dirs(dir, full.names = TRUE, recursive = FALSE)
  get_quant_paths(sub_dirs, file_name)
})

# Flatten the list of quant_paths into a named list
quant_paths <- lapply(quant_paths, unlist)

```


## Create counts matrix (tximport)
Here we create a tx level count matrix with the `tximport` function from the `tximport` library. The estimated counts are generated using abundance estimates, where counts are scaled using the median transcript length among isoforms of a gene, and then the library size (`countsFromAbundance = "dtuScaledTPM"`)
```{r Get tx counts, echo=TRUE}
# Function to import tx counts with tximport
get_dtu_from_txi <- function(quant_dir, sample_prefix_regex, type, tx2gene) {
  txi <- tximport(quant_dir,
                  type = type,
                  tx2gene = tx2gene,
                  ignoreAfterBar = TRUE,
                  countsFromAbundance = "no", # dtu scaledTPM counts used for the analysis
                  txOut = TRUE) # output tx level counts matrix 
  counts <- as.data.frame(txi$counts, stringAsFactors = FALSE)
  sample_names <- gsub(sample_prefix_regex, '', basename(dirname(quant_dir)))
  colnames(counts) <- sample_names
  rownames(counts) <- tx2gene$tx_name[match(rownames(counts), tx2gene$tx_name)]
  sparse_counts <- as(counts, "sparseMatrix")
  return(sparse_counts)
}


# Process each quant path for different bulk types
pb_sn.tx.dtu <- get_dtu_from_txi(quant_paths$pb_sn, ".*/", "oarfish", tx2gene = tx2gene[1:2])
ont_sc.tx.dtu <- get_dtu_from_txi(quant_paths$ont_sc, ".*/", "oarfish", tx2gene = tx2gene[1:2])
ont_sn.tx.dtu <- get_dtu_from_txi(quant_paths$ont_sn, ".*/", "oarfish",tx2gene = tx2gene[1:2])
pb_sc.tx.dtu <- get_dtu_from_txi(quant_paths$pb_sc, ".*/", "oarfish", tx2gene = tx2gene[1:2])

```

# Filter human tx counts
```{r}
# Filter only human tx counts 
pb_sn.txhuman.dtu <- pb_sn.tx.dtu[is.human(pb_sn.tx.dtu),]
ont_sc.txhuman.dtu <- ont_sc.tx.dtu[is.human(ont_sc.tx.dtu),]
ont_sn.txhuman.dtu <- ont_sn.tx.dtu[is.human(ont_sn.tx.dtu),]
pb_sc.txhuman.dtu <- pb_sc.tx.dtu[is.human(pb_sc.tx.dtu),]
```

## Filtering common tx & expression (human)
```{r transcript filtering for DTU, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
# Human transcript
# 1. get common transcripts
common_tx <- Reduce(intersect, lapply(list(pb_sn.txhuman.dtu, ont_sc.txhuman.dtu, ont_sn.txhuman.dtu, pb_sc.txhuman.dtu), rownames))

pb_sn.txhuman.dtu <- pb_sn.txhuman.dtu[common_tx, ]
ont_sc.txhuman.dtu <- ont_sc.txhuman.dtu[common_tx, ]
ont_sn.txhuman.dtu <- ont_sn.txhuman.dtu[common_tx, ]
pb_sc.txhuman.dtu <- pb_sc.txhuman.dtu[common_tx, ]

## 2. filter by expression (union instead of the intersection |)
bulk_meta
keep <- filterByExpr(pb_sn.txhuman.dtu, group = bulk_meta %>% arrange(match(id, colnames(pb_sn.txhuman.dtu))) %>% pull(group), min.count = 5)  & 
        filterByExpr(ont_sc.txhuman.dtu, group = bulk_meta %>% arrange(match(id, colnames(ont_sc.txhuman.dtu))) %>% pull(group), min.count = 5)  & 
        filterByExpr(ont_sn.txhuman.dtu, group = bulk_meta %>% arrange(match(id, colnames(ont_sn.txhuman.dtu))) %>% pull(group), min.count = 5)  & 
        filterByExpr(pb_sc.txhuman.dtu, group = bulk_meta %>% arrange(match(id, colnames(pb_sc.txhuman.dtu))) %>% pull(group), min.count = 5)  

table(keep)
pb_sn.txhuman.dtu <- pb_sn.txhuman.dtu[keep, ]
ont_sc.txhuman.dtu <- ont_sc.txhuman.dtu[keep, ]
ont_sn.txhuman.dtu <- ont_sn.txhuman.dtu[keep, ]
pb_sc.txhuman.dtu <- pb_sc.txhuman.dtu[keep, ]

```

## Filtering for DTU requirements  
```{r}

# DTU filtering
# 1. Remove genes with < 1 transcript 
# 2. Remove 0 counts across samples for groups within comparisons

dtu_filter <- getFromNamespace("sparse_filter", "DTUrtle")

run_dtu_filtering <- function(counts, meta, tx2gene, comparisons, ...) {
  # Initialize a list to store filtered counts per comparison
  result <- list()
  
  # Loop over each comparison (each element is a vector of two groups, e.g., c("luad", "sclc_a"))
  for (comp in comparisons) {
    comp_name <- paste(comp, collapse = "_vs_")
    message("Processing comparison: ", comp_name)
    
    # Subset metadata to samples belonging to the groups in this comparison
    meta_comp <- meta[meta$group %in% comp, ]
    samples_to_keep <- meta_comp$id
    
    # Subset the counts matrix to these samples
    counts_comp <- counts[, samples_to_keep, drop = FALSE]
    cat("Before filtering for", comp_name, ": ", nrow(counts_comp), "features\n")
    
    # Apply dtu_filter, e.g., obtained with getFromNamespace("sparse_filter", "DTUrtle")
    filtered_counts <- dtu_filter(
      counts = counts_comp,
      tx2gene = tx2gene,
      BPPARAM = BiocParallel::SerialParam(),
      min_samps_gene_expr = 0,
      min_gene_expr = 0,
      min_samps_feature_expr = 0,
      min_feature_expr = 0,
      min_samps_feature_prop = 0,
      min_feature_prop = 0,
      run_gene_twice = FALSE
    )
    
    cat("For comparison", comp_name, ": retained", nrow(filtered_counts), "features\n\n")
    
    # Store the filtered counts under the comparison name
    result[[comp_name]] <- filtered_counts
  }
  
  return(result)
}

```

```{r}
comparisons_human <- list(
  c("luad", "sclc_a"),
  c("luad", "sclc_p"),
  c("sclc_a", "sclc_p")
)

pb_sn.txhuman_filtered.dtu <- run_dtu_filtering(pb_sn.txhuman.dtu, bulk_meta, human_tx2gene, comparisons_human, dtu_filter)
ont_sc.txhuman_filtered.dtu <- run_dtu_filtering(ont_sc.txhuman.dtu, bulk_meta, human_tx2gene, comparisons_human, dtu_filter)
pb_sc.txhuman_filtered.dtu <- run_dtu_filtering(pb_sc.txhuman.dtu, bulk_meta, human_tx2gene, comparisons_human, dtu_filter)
ont_sn.txhuman_filtered.dtu <- run_dtu_filtering(ont_sn.txhuman.dtu, bulk_meta, human_tx2gene, comparisons_human, dtu_filter)

```
## Filtering common features after DTU filter
```{r}
# Repeat filter common features for each comparison across platforms
# 1. Get common feature luad_vs_sclc_a
common_tx <- Reduce(intersect, lapply(list(pb_sn.txhuman_filtered.dtu$luad_vs_sclc_a,
                                                          ont_sc.txhuman_filtered.dtu$luad_vs_sclc_a,
                                                          ont_sn.txhuman_filtered.dtu$luad_vs_sclc_a,
                                                          pb_sc.txhuman_filtered.dtu$luad_vs_sclc_a),rownames))

pb_sn.txhuman_filtered.dtu$luad_vs_sclc_a <- pb_sn.txhuman_filtered.dtu$luad_vs_sclc_a[common_tx, ]
ont_sc.txhuman_filtered.dtu$luad_vs_sclc_a <- ont_sc.txhuman_filtered.dtu$luad_vs_sclc_a[common_tx, ]
ont_sn.txhuman_filtered.dtu$luad_vs_sclc_a <- ont_sn.txhuman_filtered.dtu$luad_vs_sclc_a[common_tx, ]
pb_sc.txhuman_filtered.dtu$luad_vs_sclc_a <- pb_sc.txhuman_filtered.dtu$luad_vs_sclc_a[common_tx, ]


# 2. Get common feature luad_vs_sclc_p
common_tx <- Reduce(intersect, lapply(list(pb_sn.txhuman_filtered.dtu$luad_vs_sclc_p,
                                                          ont_sc.txhuman_filtered.dtu$luad_vs_sclc_p,
                                                          ont_sn.txhuman_filtered.dtu$luad_vs_sclc_p,
                                                          pb_sc.txhuman_filtered.dtu$luad_vs_sclc_p),rownames))

pb_sn.txhuman_filtered.dtu$luad_vs_sclc_p <- pb_sn.txhuman_filtered.dtu$luad_vs_sclc_p[common_tx, ]
ont_sc.txhuman_filtered.dtu$luad_vs_sclc_p <- ont_sc.txhuman_filtered.dtu$luad_vs_sclc_p[common_tx, ]
ont_sn.txhuman_filtered.dtu$luad_vs_sclc_p <- ont_sn.txhuman_filtered.dtu$luad_vs_sclc_p[common_tx, ]
pb_sc.txhuman_filtered.dtu$luad_vs_sclc_p <- pb_sc.txhuman_filtered.dtu$luad_vs_sclc_p[common_tx, ]


# 3. Get common feature sclc_a_vs_sclc_p
common_tx <- Reduce(intersect, lapply(list(pb_sn.txhuman_filtered.dtu$sclc_a_vs_sclc_p,
                                                          ont_sc.txhuman_filtered.dtu$sclc_a_vs_sclc_p,
                                                          ont_sn.txhuman_filtered.dtu$sclc_a_vs_sclc_p,
                                                          pb_sc.txhuman_filtered.dtu$sclc_a_vs_sclc_p),rownames))

pb_sn.txhuman_filtered.dtu$sclc_a_vs_sclc_p <- pb_sn.txhuman_filtered.dtu$sclc_a_vs_sclc_p[common_tx, ]
ont_sc.txhuman_filtered.dtu$sclc_a_vs_sclc_p <- ont_sc.txhuman_filtered.dtu$sclc_a_vs_sclc_p[common_tx, ]
ont_sn.txhuman_filtered.dtu$sclc_a_vs_sclc_p <- ont_sn.txhuman_filtered.dtu$sclc_a_vs_sclc_p[common_tx, ]
pb_sc.txhuman_filtered.dtu$sclc_a_vs_sclc_p <- pb_sc.txhuman_filtered.dtu$sclc_a_vs_sclc_p[common_tx, ]

```

# DTU analysis

First, perform the statistical analysis with `DRIMSeq`, a DTU specialized statistical framework utilizing a Dirichlet-multinomial model. This is done with the `run_drimseq` command. We use the previously imported data as parameters, specifying which column in the cell metadata data frame contains ids and which the group information we want. The order given in the `cond_levels` parameter also specifies the comparison formula

DRIMSeq is an R package designed for Differential Transcript Usage (DTU) analysis, which examines changes in the relative abundance of different isoforms (transcripts) of a gene across conditions. Instead of looking at total gene expression, DTU focuses on shifts in transcript proportions within each gene.

`Dirichlet-Multinomial Model`
The core of DRIMSeq’s statistical framework is the Dirichlet-multinomial model, which accounts for:
Biological variability in transcript usage across samples.
Overdispersion (extra variability beyond simple multinomial models).
Compositional constraints, meaning transcript proportions sum to 1 per gene.


**Workflow** 

`STEP 1` Data preprocessing - Gene-transcript coint matrices (Salmon/ Oarfish)

`STEP 2` Model Estimation (Dirichlet - Multinomial) - The model estimates dispersion (variation in transcript proportions across replicates). Genes with highly variable transcript usage are prioritized.

`STEP 3`  Differential Transcript Usage testing - Hypothesis testing to see whether transcript usage differs significantly between conditions?. Null hypothesis is that transcript proportions remain the same between group. Then DRIMseq fits a Dirichlet-multinomial generalized linear model (GLM) and applies likelihood ratio tests (LRTs) to detect significant shifts.

```{r}

runDTU_drimseq <- function(counts, tx2gene, meta, cond_col, comparisons, biocpar) {
  dtu_results <- list()
  
  # Check if 'counts' is a list (i.e. pre-split by comparison)
  if(is.list(counts)) {
    # We assume the list is keyed by names like "group1_vs_group2"
    for(comp_name in names(counts)) {
      message("Running DTU analysis for comparison: ", comp_name)
      
      # Parse the comparison groups from the name 
      groups <- unlist(strsplit(comp_name, "_vs_"))
      
      # Subset metadata for the groups
      meta_comp <- meta[meta[[cond_col]] %in% groups, ]
      
      try({
        result <- my_run_drimseq(
          counts = counts[[comp_name]],
          tx2gene = tx2gene,
          pd = meta_comp,
          id_col = "id",
          cond_col = cond_col,
          cond_levels = groups,
          add_pseudocount = TRUE,
          filtering_strategy = "none",
          BPPARAM = biocpar
        )
        dtu_results[[comp_name]] <- result
      })
    }
  } else {
    # Otherwise, assume counts is a single matrix and we need to split it by comparison
  for (comparison in comparisons) {
      comp_name <- paste(comparison, collapse = "_vs_")
      message("Running DTU analysis for comparison: ", comp_name)
      
      # Subset metadata to only samples in the current comparison
      meta_comp <- meta[meta[[cond_col]] %in% comparison, ]
      samples_to_keep <- meta_comp$id
      
      # Subset the counts matrix to these samples
      counts_comp <- counts[, samples_to_keep, drop = FALSE]
      cat("For comparison ", comp_name, ": ", ncol(counts_comp), " samples selected.\n", sep = "")
      
    try({
        result <- my_run_drimseq(
          counts = counts_comp,
        tx2gene = tx2gene,
          pd = meta_comp,
        id_col = "id",
        cond_col = cond_col,
        cond_levels = comparison,
          add_pseudocount = TRUE,
          filtering_strategy = "none",
          BPPARAM = biocpar
      )
        dtu_results[[comp_name]] <- result
    })
    }
  }
  
  return(dtu_results)
}


```


## DTU human (common feature/comparison)
```{r}
# DTU analysis on human genes only 
human_tx2gene <- as.data.frame(human_tx2gene) # ensure this is a data frame 


pb_sn.dtu_human.list <- runDTU_drimseq(counts = pb_sn.txhuman_filtered.dtu, tx2gene = human_tx2gene[1:2], meta = bulk_meta, cond_col = "group", comparisons = comparisons_human, biocpar = biocpar)

ont_sc.dtu_human.list <- runDTU_drimseq(counts = ont_sc.txhuman_filtered.dtu, tx2gene = human_tx2gene[1:2], meta = bulk_meta, cond_col = "group", comparisons = comparisons_human, biocpar = biocpar)

pb_sc.dtu_human.list <- runDTU_drimseq(counts = pb_sc.txhuman_filtered.dtu, tx2gene = human_tx2gene[1:2], meta = bulk_meta, cond_col = "group", comparisons = comparisons_human, biocpar = biocpar)

ont_sn.dtu_human.list <- runDTU_drimseq(counts = ont_sn.txhuman_filtered.dtu, tx2gene = human_tx2gene[1:2], meta = bulk_meta, cond_col = "group", comparisons = comparisons_human, biocpar = biocpar)


```

## Sanity check consistent features
```{r}
# Create a list of your DTU objects from different platforms
platform_list <- list(
  "PB SN" = pb_sn.dtu_human.list,
  "ONT SC"      = ont_sc.dtu_human.list,
  "PB SC"     = pb_sc.dtu_human.list,
  "ONT SN"   = ont_sn.dtu_human.list
)

# Extract the comparison names from one of the platforms (assumed consistent across all)
comparisons <- names(pb_sn.dtu_human.list)
cat("Comparisons found:", paste(comparisons, collapse = ", "), "\n\n")

# Loop through each comparison
for(comp in comparisons) {
  cat("Comparison:", comp, "\n")
  
  # Initialize lists to store gene and transcript IDs for common intersection
  gene_ids_list <- list()
  tx_ids_list <- list()
  
  # Loop through each platform and print per-platform summary
  for(platform in names(platform_list)) {
    dtu_obj <- platform_list[[platform]][[comp]]
    
    if(!is.null(dtu_obj$meta_table_gene) && !is.null(dtu_obj$meta_table_tx)) {
      # Assuming rownames of meta_table_gene/tx are the feature IDs (or gene IDs)
      gene_ids <- rownames(dtu_obj$meta_table_gene)
      tx_ids   <- rownames(dtu_obj$meta_table_tx)
      
      gene_ids_list[[platform]] <- gene_ids
      tx_ids_list[[platform]] <- tx_ids
      
      gene_count <- length(gene_ids)
      tx_count   <- length(tx_ids)
      cat("   Platform:", platform, "-> Genes:", gene_count, "Transcripts:", tx_count, "\n")
    } else {
      cat("   Platform:", platform, "-> DTU object missing expected meta tables.\n")
    }
  }
  
  # Compute intersection across platforms for genes and transcripts
  common_genes <- Reduce(intersect, gene_ids_list)
  common_tx    <- Reduce(intersect, tx_ids_list)
  
  cat("   Common across all platforms -> Genes:", length(common_genes),
      "Transcripts:", length(common_tx), "\n\n")
}
```



###  Filtering sig DTU results (human)
```{r}

# Process PB SN bulk DTU results and store in pb_sn.dtu_human.dturtle
pb_sn.dtu_human.dturtle <- lapply(pb_sn.dtu_human.list, function(dt) {
  dt_filtered <- DTUrtle::posthoc_and_stager(dturtle = dt, ofdr = 0.05, posthoc = 0.1)
  dt_table <- DTUrtle::create_dtu_table(dturtle = dt_filtered, 
                               add_tx_metadata = list("tx_expr_in_max" = c("exp_in", max)))
  return(dt_table)
})
names(pb_sn.dtu_human.dturtle) <- names(pb_sn.dtu_human.list)

# Process Oxford Nanopore (ONT) bulk DTU results and store in ont_sc.dtu_human.dturtle
ont_sc.dtu_human.dturtle <- lapply(ont_sc.dtu_human.list, function(dt) {
  dt_filtered <-  DTUrtle::posthoc_and_stager(dturtle = dt, ofdr = 0.05, posthoc = 0.1)
  dt_table <-  DTUrtle::create_dtu_table(dturtle = dt_filtered, 
                               add_tx_metadata = list("tx_expr_in_max" = c("exp_in", max)))
  return(dt_table)
})
names(ont_sc.dtu_human.dturtle) <- names(ont_sc.dtu_human.list)

# Process dRNA bulk DTU results and store in pb_sc.dtu_human.dturtle
pb_sc.dtu_human.dturtle <- lapply(pb_sc.dtu_human.list, function(dt) {
  dt_filtered <-  DTUrtle::posthoc_and_stager(dturtle = dt, ofdr = 0.05, posthoc = 0.1)
  dt_table <-  DTUrtle::create_dtu_table(dturtle = dt_filtered, 
                               add_tx_metadata = list("tx_expr_in_max" = c("exp_in", max)))
  return(dt_table)
})
names(pb_sc.dtu_human.dturtle) <- names(pb_sc.dtu_human.list)

# Process ONT SN (PB) bulk DTU results and store in ont_sn.dtu_human.dturtle
ont_sn.dtu_human.dturtle <- lapply(ont_sn.dtu_human.list, function(dt) {
  dt_filtered <-  DTUrtle::posthoc_and_stager(dturtle = dt, ofdr = 0.05, posthoc = 0.1)
  dt_table <-  DTUrtle::create_dtu_table(dturtle = dt_filtered, 
                               add_tx_metadata = list("tx_expr_in_max" = c("exp_in", max)))
  return(dt_table)
})
names(ont_sn.dtu_human.dturtle) <- names(ont_sn.dtu_human.list)


```

### Save results for DTU (human)
```{r}

# # Save full output from DTUrtle
# saveRDS(pb_sn.dtu_human.list, "pb_sn_dtu_human.rds")
# saveRDS(ont_sc.dtu_human.list, "ont_sc_dtu_human.rds")
# saveRDS(pb_sc.dtu_human.list, "pb_sc_dtu_human.rds")
# saveRDS(ont_sn.dtu_human.list, "ont_sn_dtu_human.rds")
# 
# # Save significant DTU results
# saveRDS(pb_sn.dtu_human.dturtle, "pb_sn_human_sigdtu.rds")
# saveRDS(ont_sc.dtu_human.dturtle, "ont_sc_human_sigdtu.rds")
# saveRDS(pb_sc.dtu_human.dturtle, "pb_sc_human_sigdtu.rds")
# saveRDS(ont_sn.dtu_human.dturtle, "ont_sn_human_sigdtu.rds")

```

# DTU cross-platform comparison
```{r echo=TRUE}
complex_upset_plot <- function(lst) {
  
  long_df <- stack(lst)

  # Make the binary membership matrix
  binary_matrix <- long_df %>%
    mutate(present = 1) %>%
    pivot_wider(names_from = ind, values_from = present, values_fill = 0)

  p <- ComplexUpset::upset(
    binary_matrix %>% dplyr::select(-values) %>% as.data.frame(),
    intersect = names(lst),
    wrap = TRUE
  )

  return(list(
    plot = p,
    matrix = binary_matrix %>% dplyr::rename(Gene = values)
  ))
}
```

## Significant DTU genes human
```{r upset plot DTU genes human, echo=TRUE, fig.height=10, fig.width=8}
lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$luad_vs_sclc_a$sig_gene,
  "ONT SC" = ont_sc.dtu_human.dturtle$luad_vs_sclc_a$sig_gene,
  "ONT SN" = ont_sn.dtu_human.dturtle$luad_vs_sclc_a$sig_gene,
  "PS SC" = pb_sc.dtu_human.dturtle$luad_vs_sclc_a$sig_gene
)

p1 <- complex_upset_plot(lst)$plot + ggtitle("LUAD vs SCLC_A") + theme(plot.title = element_text(size =10))
mat.AvsL.DE <- complex_upset_plot(lst)$matrix

lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$luad_vs_sclc_p$sig_gene,
  "ONT SC" = ont_sc.dtu_human.dturtle$luad_vs_sclc_p$sig_gene,
  "ONT SN" = ont_sn.dtu_human.dturtle$luad_vs_sclc_p$sig_gene,
  "PS SC" = pb_sc.dtu_human.dturtle$luad_vs_sclc_p$sig_gene
)
p2 <- complex_upset_plot(lst)$plot + ggtitle("LUAD vs SCLC_P") + theme(plot.title = element_text(size = 10))
mat.PvsL.DE <- complex_upset_plot(lst)$matrix

lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene,
  "ONT SC" = ont_sc.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene,
  "ONT SN" = ont_sn.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene,
  "PS SC" = pb_sc.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene
)
p3 <- complex_upset_plot(lst)$plot + ggtitle("SCLC_A vs SCLC_P") + theme(plot.title = element_text(size = 10))
mat.AvsP.DE <- complex_upset_plot(lst)$matrix

(p1 / p2 / p3) + patchwork::plot_annotation(
  title = "DTU Significant Human Genes",
  theme = theme(plot.title = element_text(size =15))
)

```




## Significant DTU transcripts human

```{r upset plot DTU transcripts human, echo=TRUE, fig.height=10, fig.width=8}
lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$luad_vs_sclc_a$sig_tx,
  "ONT SC" = ont_sc.dtu_human.dturtle$luad_vs_sclc_a$sig_tx,
  "ONT SN" = ont_sn.dtu_human.dturtle$luad_vs_sclc_a$sig_tx,
  "PS SC" = pb_sc.dtu_human.dturtle$luad_vs_sclc_a$sig_tx
)

p1 <- complex_upset_plot(lst)$plot + ggtitle("LUAD vs SCLC_A") + theme(plot.title = element_text(size =10))
mat.AvsL.DE <- complex_upset_plot(lst)$matrix

lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$luad_vs_sclc_p$sig_tx,
  "ONT SC" = ont_sc.dtu_human.dturtle$luad_vs_sclc_p$sig_tx,
  "ONT SN" = ont_sn.dtu_human.dturtle$luad_vs_sclc_p$sig_tx,
  "PS SC" = pb_sc.dtu_human.dturtle$luad_vs_sclc_p$sig_tx
)
p2 <- complex_upset_plot(lst)$plot + ggtitle("LUAD vs SCLC_P") + theme(plot.title = element_text(size = 10))
mat.PvsL.DE <- complex_upset_plot(lst)$matrix

lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_tx,
  "ONT SC" = ont_sc.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_tx,
  "ONT SN" = ont_sn.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_tx,
  "PS SC" = pb_sc.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_tx
)
p3 <- complex_upset_plot(lst)$plot + ggtitle("SCLC_A vs SCLC_P") + theme(plot.title = element_text(size = 10))
mat.AvsP.DE <- complex_upset_plot(lst)$matrix

(p1 / p2 / p3) + patchwork::plot_annotation(
  title = "DTU Significant Human Transcripts",
  theme = theme(plot.title = element_text(size =15))
)
 
```

## Overlap with bulk:
```{r}

```



```{r}
ont_bulk.bulk.rds <- readRDS("/vast/projects/LongBench/analysis/workflow/rmarkdown/ont_bulk_human_sigdtu.rds")
pb_bulk.bulk.rds <- readRDS("/vast/projects/LongBench/analysis/workflow/rmarkdown/pb_bulk_human_sigdtu.rds")
ill_bulk.bulk.rds <- readRDS("/vast/projects/LongBench/analysis/workflow/rmarkdown/ill_bulk_human_sigdtu.rds")
drna_bulk.bulk.rds <- readRDS("/vast/projects/LongBench/analysis/workflow/rmarkdown/drna_bulk_human_sigdtu.rds")
```


```{r}
complex_upset_plot <- function(lst, bulk.any = NULL, bulk.all = NULL) {
  lst.plot <- lst
  lst.plot[["Bulk DE any"]] <- bulk.any
  lst.plot[["Bulk DE all"]] <- bulk.all
  long_df <- stack(lst.plot)

  # Make the binary membership matrix
  binary_matrix <- long_df %>%
    mutate(present = 1) %>%
    pivot_wider(names_from = ind, values_from = present, values_fill = 0)
  
  binary_matrix$`Bulk DE any` <- binary_matrix$`Bulk DE any` %>% as.logical()
  binary_matrix$`Bulk DE all` <- binary_matrix$`Bulk DE all` %>% as.logical()
  binary_matrix$`Bulk DE` <- factor(
    ifelse(!binary_matrix$`Bulk DE any`, "Not DTU in any bulk dataset",
      ifelse(
        binary_matrix$`Bulk DE all`, "DTU in all bulk datasets", "DTU in any bulk dataset"
      )
    ),
    levels = c("Not DTU in any bulk dataset", "DTU in any bulk dataset", "DTU in all bulk datasets")
  )

  # remove the bulk Bulk DE levels


  p <- ComplexUpset::upset(
    binary_matrix %>% select(-values) %>% as.data.frame(),
    intersect = names(lst),
    wrap = TRUE,
    base_annotations=list(
      "Intersection size" = intersection_size(
        mapping = aes(fill = `Bulk DE`)
      ) + scale_fill_manual(
                values = c(
                  "Not DTU in any bulk dataset" = "grey",
                  "DTU in any bulk dataset" = "#84d28e", 
                  "DTU in all bulk datasets" = "#27ca0b"
                )
            ) + theme(legend.position = "none")
    ),
    set_sizes=(
        upset_set_size(
            geom=geom_bar(
                aes(fill=`Bulk DE`, x=group),
                width=0.8
            ),
            position = 'right',
        )  + scale_fill_manual(
                values = c(
                  "Not DTU in any bulk dataset" = "grey",
                  "DTU in any bulk dataset" = "#84d28e", 
                  "DTU in all bulk datasets" = "#27ca0b"
                )
            ) 
    ),
    guides='over'
  )

  return(list(
    plot = p,
    matrix = binary_matrix %>% rename(Gene = values)
  ))
}
```

```{r upset plot DTU gene human (overlap with bulk), echo=TRUE, fig.height=10, fig.width=8}
lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$luad_vs_sclc_a$sig_gene,
  "ONT SC" = ont_sc.dtu_human.dturtle$luad_vs_sclc_a$sig_gene,
  "ONT SN" = ont_sn.dtu_human.dturtle$luad_vs_sclc_a$sig_gene,
  "PS SC" = pb_sc.dtu_human.dturtle$luad_vs_sclc_a$sig_gene
)
bulk.any <- Reduce(union, list(
  ont_bulk.bulk.rds$luad_vs_sclc_a$sig_gene,
  pb_bulk.bulk.rds$luad_vs_sclc_a$sig_gene,
  ill_bulk.bulk.rds$luad_vs_sclc_a$sig_gene,
  drna_bulk.bulk.rds$luad_vs_sclc_a$sig_gene
))
bulk.all <- Reduce(intersect, list(
  ont_bulk.bulk.rds$luad_vs_sclc_a$sig_gene,
  pb_bulk.bulk.rds$luad_vs_sclc_a$sig_gene,
  ill_bulk.bulk.rds$luad_vs_sclc_a$sig_gene,
  drna_bulk.bulk.rds$luad_vs_sclc_a$sig_gene
))

p1 <- complex_upset_plot(lst, bulk.any, bulk.all)$plot + ggtitle("LUAD vs SCLC_A") + theme(plot.title = element_text(size =10))


lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$luad_vs_sclc_p$sig_gene,
  "ONT SC" = ont_sc.dtu_human.dturtle$luad_vs_sclc_p$sig_gene,
  "ONT SN" = ont_sn.dtu_human.dturtle$luad_vs_sclc_p$sig_gene,
  "PS SC" = pb_sc.dtu_human.dturtle$luad_vs_sclc_p$sig_gene
)
bulk.any <- Reduce(union, list(
  ont_bulk.bulk.rds$luad_vs_sclc_p$sig_gene,
  pb_bulk.bulk.rds$luad_vs_sclc_p$sig_gene,
  ill_bulk.bulk.rds$luad_vs_sclc_p$sig_gene,
  drna_bulk.bulk.rds$luad_vs_sclc_p$sig_gene
))
bulk.all <- Reduce(intersect, list(
  ont_bulk.bulk.rds$luad_vs_sclc_p$sig_gene,
  pb_bulk.bulk.rds$luad_vs_sclc_p$sig_gene,
  ill_bulk.bulk.rds$luad_vs_sclc_p$sig_gene,
  drna_bulk.bulk.rds$luad_vs_sclc_p$sig_gene
))

p2 <- complex_upset_plot(lst, bulk.any, bulk.all)$plot + ggtitle("LUAD vs SCLC_P") + theme(plot.title = element_text(size = 10))

lst <- list(
  "PB SN" = pb_sn.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene,
  "ONT SC" = ont_sc.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene,
  "ONT SN" = ont_sn.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene,
  "PS SC" = pb_sc.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene
)
bulk.any <- Reduce(union, list(
  ont_bulk.bulk.rds$sclc_a_vs_sclc_p$sig_gene,
  pb_bulk.bulk.rds$sclc_a_vs_sclc_p$sig_gene,
  ill_bulk.bulk.rds$sclc_a_vs_sclc_p$sig_gene,
  drna_bulk.bulk.rds$sclc_a_vs_sclc_p$sig_gene
))
bulk.all <- Reduce(intersect, list(
  ont_bulk.bulk.rds$sclc_a_vs_sclc_p$sig_gene,
  pb_bulk.bulk.rds$sclc_a_vs_sclc_p$sig_gene,
  ill_bulk.bulk.rds$sclc_a_vs_sclc_p$sig_gene,
  drna_bulk.bulk.rds$sclc_a_vs_sclc_p$sig_gene
))
p3 <- complex_upset_plot(lst, bulk.any, bulk.all)$plot + ggtitle("SCLC_A vs SCLC_P") + theme(plot.title = element_text(size = 10))

(p1 / p2 / p3) + patchwork::plot_annotation(
  title = "DTU Significant Human Genes",
  theme = theme(plot.title = element_text(size =15))
)
```


#Humans DTU summary 
```{r}

library(ggplot2)
library(dplyr)
library(forcats)
library(patchwork)

# Define custom color palette (names must match your platform names)
used_palette <- c(
  `PB SN` = "#ff9b9b",
  `ONT SC` = "#04476c",
  `ONT SN`   = "#24cdcd",
  `PS SC` = "#df1995"
)



# Construct a data frame for power (number of significant DTU genes) for human genes
# (Using your DTU results for the "luad_vs_sclc_a", "luad_vs_sclc_p", and "sclc_a_vs_sclc_p" comparisons)
df_power <- data.frame(
  Comparison = rep(c("luad_vs_sclc_a", "luad_vs_sclc_p", "sclc_a_vs_sclc_p"), each = 4),
  Platform = rep(c("PB SN", "ONT SC", "ONT SN", "PS SC"), times = 3),
  Power = c(
    length(pb_sn.dtu_human.dturtle$luad_vs_sclc_a$sig_gene),
    length(ont_sc.dtu_human.dturtle$luad_vs_sclc_a$sig_gene),
    length(ont_sn.dtu_human.dturtle$luad_vs_sclc_a$sig_gene),
    length(pb_sc.dtu_human.dturtle$luad_vs_sclc_a$sig_gene),
    
    length(pb_sn.dtu_human.dturtle$luad_vs_sclc_p$sig_gene),
    length(ont_sc.dtu_human.dturtle$luad_vs_sclc_p$sig_gene),
    length(ont_sn.dtu_human.dturtle$luad_vs_sclc_p$sig_gene),
    length(pb_sc.dtu_human.dturtle$luad_vs_sclc_p$sig_gene),
    
    length(pb_sn.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene),
    length(ont_sc.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene),
    length(ont_sn.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene),
    length(pb_sc.dtu_human.dturtle$sclc_a_vs_sclc_p$sig_gene)
  ),
  stringsAsFactors = FALSE
)

comp_levels <- c("luad_vs_sclc_a", "luad_vs_sclc_p", "sclc_a_vs_sclc_p")
df_power$Comparison <- factor(df_power$Comparison, levels = comp_levels)


df_bar <- df_power %>% 
  group_by(Comparison) %>% 
  mutate(Platform_ordered = fct_reorder(Platform, Power, .desc = TRUE)) %>% 
  ungroup()

p_bar <- ggplot(df_bar, aes(x = Platform_ordered, y = Power, fill = Platform_ordered)) +
  geom_bar(stat = "identity", width = 0.7) +
  geom_text(aes(label = Power), vjust = -0.5, size = 3) +
  facet_wrap(~ Comparison, scales = "free_x") +
  scale_fill_manual(values = used_palette) +
  labs(
    title = "DTU Significant Human Genes ",
    x = "Platform",
    y = "Number of Significant DTU Calls"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "none"
  )


df_line <- df_power %>% 
  mutate(Comparison_numeric = as.numeric(Comparison))

p_line <- ggplot(df_line, aes(x = Comparison_numeric, y = Power, group = Platform, color = Platform)) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  scale_x_continuous(breaks = 1:length(comp_levels), labels = comp_levels) +
  scale_color_manual(values = used_palette) +
  labs(
    title = "",
    x = "Comparison",
    y = "Number of Significant DTU Calls"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right"
  )

combined_plot <- p_bar | p_line +
  patchwork::plot_annotation(
    title = "DTU Significant Human Genes (Power)",
    theme = theme(plot.title = element_text(size = 20))
  )

# Display the combined plot
print(combined_plot)




```
